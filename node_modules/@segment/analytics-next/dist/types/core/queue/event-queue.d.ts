import { Analytics } from '../analytics';
import { PriorityQueue } from '../../lib/priority-queue';
import { Context } from '../context';
import { Emitter } from '@segment/analytics-core';
import { Plugin } from '../plugin';
import { TaskGroup } from '../task/task-group';
export declare class EventQueue extends Emitter {
    /**
     * All event deliveries get suspended until all the tasks in this task group are complete.
     * For example: a middleware that augments the event object should be loaded safely as a
     * critical task, this way, event queue will wait for it to be ready before sending events.
     *
     * This applies to all the events already in the queue, and the upcoming ones
     */
    criticalTasks: TaskGroup;
    queue: PriorityQueue<Context>;
    plugins: Plugin[];
    failedInitializations: string[];
    private flushing;
    constructor(priorityQueue?: PriorityQueue<Context>);
    register(ctx: Context, plugin: Plugin, instance: Analytics): Promise<void>;
    deregister(ctx: Context, plugin: Plugin, instance: Analytics): Promise<void>;
    dispatch(ctx: Context): Promise<Context>;
    private subscribeToDelivery;
    dispatchSingle(ctx: Context): Promise<Context>;
    isEmpty(): boolean;
    private scheduleFlush;
    private deliver;
    private enqueuRetry;
    flush(): Promise<Context[]>;
    private isReady;
    private availableExtensions;
    private flushOne;
}
//# sourceMappingURL=event-queue.d.ts.map