import { asPromise } from '../../lib/as-promise';
export function pTimeout(cb, timeout) {
    return new Promise(function (resolve, reject) {
        var timeoutId = setTimeout(function () {
            reject(Error('Promise timed out'));
        }, timeout);
        cb.then(function (val) {
            clearTimeout(timeoutId);
            return resolve(val);
        }).catch(reject);
    });
}
function sleep(timeoutInMs) {
    return new Promise(function (resolve) { return setTimeout(resolve, timeoutInMs); });
}
/**
 * @param delayTimeout - The amount of time in ms to wait before invoking the callback.
 * @param timeout - The maximum amount of time in ms to allow the callback to run for.
 */
export function invokeCallback(ctx, callback, delayTimeout, timeout) {
    var cb = function () {
        try {
            return asPromise(callback(ctx));
        }
        catch (err) {
            return Promise.reject(err);
        }
    };
    return (sleep(delayTimeout)
        // pTimeout ensures that the callback can't cause the context to hang
        .then(function () { return pTimeout(cb(), timeout !== null && timeout !== void 0 ? timeout : 1000); })
        .catch(function (err) {
        ctx === null || ctx === void 0 ? void 0 : ctx.log('warn', 'Callback Error', { error: err });
        ctx === null || ctx === void 0 ? void 0 : ctx.stats.increment('callback_error');
    })
        .then(function () { return ctx; }));
}
//# sourceMappingURL=index.js.map