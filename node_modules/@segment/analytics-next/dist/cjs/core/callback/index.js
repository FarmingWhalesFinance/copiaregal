"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.invokeCallback = exports.pTimeout = void 0;
var as_promise_1 = require("../../lib/as-promise");
function pTimeout(cb, timeout) {
    return new Promise(function (resolve, reject) {
        var timeoutId = setTimeout(function () {
            reject(Error('Promise timed out'));
        }, timeout);
        cb.then(function (val) {
            clearTimeout(timeoutId);
            return resolve(val);
        }).catch(reject);
    });
}
exports.pTimeout = pTimeout;
function sleep(timeoutInMs) {
    return new Promise(function (resolve) { return setTimeout(resolve, timeoutInMs); });
}
/**
 * @param delayTimeout - The amount of time in ms to wait before invoking the callback.
 * @param timeout - The maximum amount of time in ms to allow the callback to run for.
 */
function invokeCallback(ctx, callback, delayTimeout, timeout) {
    var cb = function () {
        try {
            return (0, as_promise_1.asPromise)(callback(ctx));
        }
        catch (err) {
            return Promise.reject(err);
        }
    };
    return (sleep(delayTimeout)
        // pTimeout ensures that the callback can't cause the context to hang
        .then(function () { return pTimeout(cb(), timeout !== null && timeout !== void 0 ? timeout : 1000); })
        .catch(function (err) {
        ctx === null || ctx === void 0 ? void 0 : ctx.log('warn', 'Callback Error', { error: err });
        ctx === null || ctx === void 0 ? void 0 : ctx.stats.increment('callback_error');
    })
        .then(function () { return ctx; }));
}
exports.invokeCallback = invokeCallback;
//# sourceMappingURL=index.js.map