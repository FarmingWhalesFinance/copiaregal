{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Facade = void 0;\n\nvar address_1 = __importDefault(require(\"./address\"));\n\nvar clone_1 = require(\"./clone\");\n\nvar is_enabled_1 = __importDefault(require(\"./is-enabled\"));\n\nvar new_date_1 = __importDefault(require(\"new-date\"));\n\nvar obj_case_1 = __importDefault(require(\"obj-case\"));\n\nvar isodate_traverse_1 = __importDefault(require(\"@segment/isodate-traverse\"));\n\nfunction Facade(obj, opts) {\n  opts = opts || {};\n  this.raw = clone_1.clone(obj);\n  if (!(\"clone\" in opts)) opts.clone = true;\n  if (opts.clone) obj = clone_1.clone(obj);\n  if (!(\"traverse\" in opts)) opts.traverse = true;\n  if (!(\"timestamp\" in obj)) obj.timestamp = new Date();else obj.timestamp = new_date_1.default(obj.timestamp);\n  if (opts.traverse) isodate_traverse_1.default(obj);\n  this.opts = opts;\n  this.obj = obj;\n}\n\nexports.Facade = Facade;\nvar f = Facade.prototype;\n\nf.proxy = function (field) {\n  var fields = field.split(\".\");\n  field = fields.shift();\n  var obj = this[field] || this.field(field);\n  if (!obj) return obj;\n  if (typeof obj === \"function\") obj = obj.call(this) || {};\n  if (fields.length === 0) return this.opts.clone ? transform(obj) : obj;\n  obj = obj_case_1.default(obj, fields.join(\".\"));\n  return this.opts.clone ? transform(obj) : obj;\n};\n\nf.field = function (field) {\n  var obj = this.obj[field];\n  return this.opts.clone ? transform(obj) : obj;\n};\n\nFacade.proxy = function (field) {\n  return function () {\n    return this.proxy(field);\n  };\n};\n\nFacade.field = function (field) {\n  return function () {\n    return this.field(field);\n  };\n};\n\nFacade.multi = function (path) {\n  return function () {\n    var multi = this.proxy(path + \"s\");\n    if (Array.isArray(multi)) return multi;\n    var one = this.proxy(path);\n    if (one) one = [this.opts.clone ? clone_1.clone(one) : one];\n    return one || [];\n  };\n};\n\nFacade.one = function (path) {\n  return function () {\n    var one = this.proxy(path);\n    if (one) return one;\n    var multi = this.proxy(path + \"s\");\n    if (Array.isArray(multi)) return multi[0];\n  };\n};\n\nf.json = function () {\n  var ret = this.opts.clone ? clone_1.clone(this.obj) : this.obj;\n  if (this.type) ret.type = this.type();\n  return ret;\n};\n\nf.rawEvent = function () {\n  return this.raw;\n};\n\nf.options = function (integration) {\n  var obj = this.obj.options || this.obj.context || {};\n  var options = this.opts.clone ? clone_1.clone(obj) : obj;\n  if (!integration) return options;\n  if (!this.enabled(integration)) return;\n  var integrations = this.integrations();\n  var value = integrations[integration] || obj_case_1.default(integrations, integration);\n  if (typeof value !== \"object\") value = obj_case_1.default(this.options(), integration);\n  return typeof value === \"object\" ? value : {};\n};\n\nf.context = f.options;\n\nf.enabled = function (integration) {\n  var allEnabled = this.proxy(\"options.providers.all\");\n  if (typeof allEnabled !== \"boolean\") allEnabled = this.proxy(\"options.all\");\n  if (typeof allEnabled !== \"boolean\") allEnabled = this.proxy(\"integrations.all\");\n  if (typeof allEnabled !== \"boolean\") allEnabled = true;\n  var enabled = allEnabled && is_enabled_1.default(integration);\n  var options = this.integrations();\n\n  if (options.providers && options.providers.hasOwnProperty(integration)) {\n    enabled = options.providers[integration];\n  }\n\n  if (options.hasOwnProperty(integration)) {\n    var settings = options[integration];\n\n    if (typeof settings === \"boolean\") {\n      enabled = settings;\n    } else {\n      enabled = true;\n    }\n  }\n\n  return !!enabled;\n};\n\nf.integrations = function () {\n  return this.obj.integrations || this.proxy(\"options.providers\") || this.options();\n};\n\nf.active = function () {\n  var active = this.proxy(\"options.active\");\n  if (active === null || active === undefined) active = true;\n  return active;\n};\n\nf.anonymousId = function () {\n  return this.field(\"anonymousId\") || this.field(\"sessionId\");\n};\n\nf.sessionId = f.anonymousId;\nf.groupId = Facade.proxy(\"options.groupId\");\n\nf.traits = function (aliases) {\n  var ret = this.proxy(\"options.traits\") || {};\n  var id = this.userId();\n  aliases = aliases || {};\n  if (id) ret.id = id;\n\n  for (var alias in aliases) {\n    var value = this[alias] == null ? this.proxy(\"options.traits.\" + alias) : this[alias]();\n    if (value == null) continue;\n    ret[aliases[alias]] = value;\n    delete ret[alias];\n  }\n\n  return ret;\n};\n\nf.library = function () {\n  var library = this.proxy(\"options.library\");\n  if (!library) return {\n    name: \"unknown\",\n    version: null\n  };\n  if (typeof library === \"string\") return {\n    name: library,\n    version: null\n  };\n  return library;\n};\n\nf.device = function () {\n  var device = this.proxy(\"context.device\");\n\n  if (typeof device !== \"object\" || device === null) {\n    device = {};\n  }\n\n  var library = this.library().name;\n  if (device.type) return device;\n  if (library.indexOf(\"ios\") > -1) device.type = \"ios\";\n  if (library.indexOf(\"android\") > -1) device.type = \"android\";\n  return device;\n};\n\nf.userAgent = Facade.proxy(\"context.userAgent\");\nf.timezone = Facade.proxy(\"context.timezone\");\nf.timestamp = Facade.field(\"timestamp\");\nf.channel = Facade.field(\"channel\");\nf.ip = Facade.proxy(\"context.ip\");\nf.userId = Facade.field(\"userId\");\naddress_1.default(f);\n\nfunction transform(obj) {\n  return clone_1.clone(obj);\n}","map":{"version":3,"sources":["../lib/facade.js"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\n\nimport address from \"./address\";\nimport { clone } from \"./clone\";\nimport isEnabled from \"./is-enabled\";\nimport newDate from \"new-date\";\nimport objCase from \"obj-case\";\nimport traverse from \"@segment/isodate-traverse\";\n\n/**\n * A *Facade* is an object meant for creating convience wrappers around\n * objects. When developing integrations, you probably want to look at its\n * subclasses, such as {@link Track} or {@link Identify}, rather than this\n * general-purpose class.\n *\n * This letructor will initialize a new `Facade` with an `obj` of arguments.\n *\n * If the inputted `obj` doesn't have a `timestamp` property, one will be added\n * with the value `new Date()`. Otherwise, the `timestamp` property will be\n * converted to a Date using the `new-date` package.\n *\n * By default, the inputted object will be defensively copied, and all ISO\n * strings present in the string will be converted into Dates.\n *\n * @param {Object} obj - The object to wrap.\n * @param {Object} opts - Options about what kind of Facade to create.\n * @param {boolean} [opts.clone=true] - Whether to make defensive clones. If enabled,\n * the inputted object will be cloned, and any objects derived from this facade\n * will be cloned before being returned.\n * @param {boolean} [opts.traverse=true] - Whether to perform ISODate-Traverse\n * on the inputted object.\n *\n * @see {@link https://github.com/segmentio/new-date|new-date}\n * @see {@link https://github.com/segmentio/isodate-traverse|isodate-traverse}\n */\nexport function Facade (obj, opts) {\n  opts = opts || {};\n  this.raw = clone(obj);\n  if (!(\"clone\" in opts)) opts.clone = true;\n  if (opts.clone) obj = clone(obj);\n  if (!(\"traverse\" in opts)) opts.traverse = true;\n  if (!(\"timestamp\" in obj)) obj.timestamp = new Date();\n  else obj.timestamp = newDate(obj.timestamp);\n  if (opts.traverse) traverse(obj);\n  this.opts = opts;\n  this.obj = obj;\n}\n\nconst f = Facade.prototype;\n\n/**\n * Get a potentially-nested field in this facade. `field` should be a\n * period-separated sequence of properties.\n *\n * If the first field passed in points to a function (e.g. the `field` passed\n * in is `a.b.c` and this facade's `obj.a` is a function), then that function\n * will be called, and then the deeper fields will be fetched (using obj-case)\n * from what that function returns. If the first field isn't a function, then\n * this function works just like obj-case.\n *\n * Because this function uses obj-case, the camel- or snake-case of the input\n * is irrelevant.\n *\n * @example\n * YourClass.prototype.height = function() {\n *   return this.proxy('getDimensions.height') ||\n *     this.proxy('props.size.side_length');\n * }\n * @param {string} field - A sequence of properties, joined by periods (`.`).\n * @return {*} - A property of the inputted object.\n * @see {@link https://github.com/segmentio/obj-case|obj-case}\n */\nf.proxy = function(field) {\n  let fields = field.split(\".\");\n  field = fields.shift();\n\n  // Call a function at the beginning to take advantage of facaded fields\n  let obj = this[field] || this.field(field);\n  if (!obj) return obj;\n  if (typeof obj === \"function\") obj = obj.call(this) || {};\n  if (fields.length === 0) return this.opts.clone ? transform(obj) : obj;\n\n  obj = objCase(obj, fields.join(\".\"));\n  return this.opts.clone ? transform(obj) : obj;\n};\n\n/**\n * Directly access a specific `field` from the underlying object. Only\n * \"top-level\" fields will work with this function. \"Nested\" fields *will not\n * work* with this function.\n *\n * @param {string} field\n * @return {*}\n */\nf.field = function(field) {\n  let obj = this.obj[field];\n  return this.opts.clone ? transform(obj) : obj;\n};\n\n/**\n * Utility method to always proxy a particular `field`. In other words, it\n * returns a function that will always return `this.proxy(field)`.\n *\n * @example\n * MyClass.prototype.height = Facade.proxy('options.dimensions.height');\n *\n * @param {string} field\n * @return {Function}\n */\nFacade.proxy = function(field) {\n  return function() {\n    return this.proxy(field);\n  };\n};\n\n/**\n * Utility method to always access a `field`. In other words, it returns a\n * function that will always return `this.field(field)`.\n *\n * @param {string} field\n * @return {Function}\n */\nFacade.field = function(field) {\n  return function() {\n    return this.field(field);\n  };\n};\n\n/**\n * Create a helper function for fetching a \"plural\" thing.\n *\n * The generated method will take the inputted `path` and append an \"s\" to it\n * and calls `this.proxy` with this \"pluralized\" path. If that produces an\n * array, that will be returned. Otherwise, a one-element array containing\n * `this.proxy(path)` will be returned.\n *\n * @example\n * MyClass.prototype.birds = Facade.multi('animals.bird');\n *\n * @param {string} path\n * @return {Function}\n */\nFacade.multi = function(path) {\n  return function() {\n    let multi = this.proxy(path + \"s\");\n    if (Array.isArray(multi)) return multi;\n    let one = this.proxy(path);\n    if (one) one = [this.opts.clone ? clone(one) : one];\n    return one || [];\n  };\n};\n\n/**\n * Create a helper function for getting a \"singular\" thing.\n *\n * The generated method will take the inputted path and call\n * `this.proxy(path)`. If a truthy thing is produced, it will be returned.\n * Otherwise, `this.proxy(path + 's')` will be called, and if that produces an\n * array the first element of that array will be returned. Otherwise,\n * `undefined` is returned.\n *\n * @example\n * MyClass.prototype.bird = Facade.one('animals.bird');\n *\n * @param {string} path\n * @return {Function}\n */\nFacade.one = function(path) {\n  return function() {\n    let one = this.proxy(path);\n    if (one) return one;\n    let multi = this.proxy(path + \"s\");\n    if (Array.isArray(multi)) return multi[0];\n  };\n};\n\n/**\n * Gets the underlying object this facade wraps around.\n *\n * If this facade has a property `type`, it will be invoked as a function and\n * will be assigned as the property `type` of the outputted object.\n *\n * @return {Object}\n */\nf.json = function() {\n  let ret = this.opts.clone ? clone(this.obj) : this.obj;\n  if (this.type) ret.type = this.type();\n  return ret;\n};\n\n/**\n * Gets a copy of the unmodified input object this facade wraps around.\n * \n * Unlike the `json` method which does make some subtle modifications \n * to datetime values and the `type` property. This method returns a copy of \n * the unmodified input object\n * \n * @return {Object}\n */\nf.rawEvent = function() {\n  return this.raw;\n};\n\n/**\n * Get the options of a call. If an integration is passed, only the options for\n * that integration are included. If the integration is not enabled, then\n * `undefined` is returned.\n *\n * Options are taken from the `options` property of the underlying object,\n * falling back to the object's `context` or simply `{}`.\n *\n * @param {string} integration - The name of the integration to get settings\n * for. Casing does not matter.\n * @return {Object|undefined}\n */\nf.options = function(integration) {\n  let obj = this.obj.options || this.obj.context || {};\n  let options = this.opts.clone ? clone(obj) : obj;\n  if (!integration) return options;\n  if (!this.enabled(integration)) return;\n  let integrations = this.integrations();\n  let value = integrations[integration] || objCase(integrations, integration);\n  if (typeof value !== \"object\") value = objCase(this.options(), integration);\n  return typeof value === \"object\" ? value : {};\n};\n\n/**\n * An alias for {@link Facade#options}.\n */\nf.context = f.options;\n\n/**\n * Check whether an integration is enabled.\n *\n * Basically, this method checks whether this integration is explicitly\n * enabled. If it isn'texplicitly mentioned, it checks whether it has been\n * enabled at the global level. Some integrations (e.g. Salesforce), cannot\n * enabled by these global event settings.\n *\n * More concretely, the deciding factors here are:\n *\n * 1. If `this.integrations()` has the integration set to `true`, return `true`.\n * 2. If `this.integrations().providers` has the integration set to `true`, return `true`.\n * 3. If integrations are set to default-disabled via global parameters (i.e.\n * `options.providers.all`, `options.all`, or `integrations.all`), then return\n * false.\n * 4. If the integration is one of the special default-deny integrations\n * (currently, only Salesforce), then return false.\n * 5. Else, return true.\n *\n * @param {string} integration\n * @return {boolean}\n */\nf.enabled = function(integration) {\n  let allEnabled = this.proxy(\"options.providers.all\");\n  if (typeof allEnabled !== \"boolean\") allEnabled = this.proxy(\"options.all\");\n  if (typeof allEnabled !== \"boolean\")\n    allEnabled = this.proxy(\"integrations.all\");\n  if (typeof allEnabled !== \"boolean\") allEnabled = true;\n\n  let enabled = allEnabled && isEnabled(integration);\n  let options = this.integrations();\n\n  // If the integration is explicitly enabled or disabled, use that\n  // First, check options.providers for backwards compatibility\n  if (options.providers && options.providers.hasOwnProperty(integration)) {\n    enabled = options.providers[integration];\n  }\n\n  // Next, check for the integration's existence in 'options' to enable it.\n  // If the settings are a boolean, use that, otherwise it should be enabled.\n  if (options.hasOwnProperty(integration)) {\n    let settings = options[integration];\n    if (typeof settings === \"boolean\") {\n      enabled = settings;\n    } else {\n      enabled = true;\n    }\n  }\n\n  return !!enabled;\n};\n\n/**\n * Get all `integration` options.\n *\n * @ignore\n * @param {string} integration\n * @return {Object}\n */\nf.integrations = function() {\n  return (\n    this.obj.integrations || this.proxy(\"options.providers\") || this.options()\n  );\n};\n\n/**\n * Check whether the user is active.\n *\n * @return {boolean}\n */\nf.active = function() {\n  let active = this.proxy(\"options.active\");\n  if (active === null || active === undefined) active = true;\n  return active;\n};\n\n/**\n * Get `sessionId / anonymousId`.\n *\n * @return {*}\n */\nf.anonymousId = function() {\n  return this.field(\"anonymousId\") || this.field(\"sessionId\");\n};\n\n/**\n * An alias for {@link Facade#anonymousId}.\n *\n * @function\n * @return {string}\n */\nf.sessionId = f.anonymousId;\n\n/**\n * Get `groupId` from `context.groupId`.\n *\n * @function\n * @return {string}\n */\nf.groupId = Facade.proxy(\"options.groupId\");\n\n/**\n * Get the call's \"traits\". All event types can pass in traits, though {@link\n * Identify} and {@link Group} override this implementation.\n *\n * Traits are gotten from `options.traits`, augmented with a property `id` with\n * the event's `userId`.\n *\n * The parameter `aliases` is meant to transform keys in `options.traits` into\n * new keys. Each alias like `{ \"xxx\": \"yyy\" }` will take whatever is at `xxx`\n * in the traits, and move it to `yyy`. If `xxx` is a method of this facade,\n * it'll be called as a function instead of treated as a key into the traits.\n *\n * @example\n * let obj = { options: { traits: { foo: \"bar\" } }, anonymousId: \"xxx\" }\n * let facade = new Facade(obj)\n *\n * facade.traits() // { \"foo\": \"bar\" }\n * facade.traits({ \"foo\": \"asdf\" }) // { \"asdf\": \"bar\" }\n * facade.traits({ \"sessionId\": \"rofl\" }) // { \"rofl\": \"xxx\" }\n *\n * @param {Object} aliases - A mapping from keys to the new keys they should be\n * transformed to.\n * @return {Object}\n */\nf.traits = function(aliases) {\n  let ret = this.proxy(\"options.traits\") || {};\n  let id = this.userId();\n  aliases = aliases || {};\n\n  if (id) ret.id = id;\n\n  for (let alias in aliases) {\n    let value =\n      this[alias] == null\n        ? this.proxy(\"options.traits.\" + alias)\n        : this[alias]();\n    if (value == null) continue;\n    ret[aliases[alias]] = value;\n    delete ret[alias];\n  }\n\n  return ret;\n};\n\n/**\n * The library and version of the client used to produce the message.\n *\n * If the library name cannot be determined, it is set to `\"unknown\"`. If the\n * version cannot be determined, it is set to `null`.\n *\n * @return {{name: string, version: string}}\n */\nf.library = function() {\n  let library = this.proxy(\"options.library\");\n  if (!library) return { name: \"unknown\", version: null };\n  if (typeof library === \"string\") return { name: library, version: null };\n  return library;\n};\n\n/**\n * Return the device information, falling back to an empty object.\n *\n * Interesting values of `type` are `\"ios\"` and `\"android\"`, but other values\n * are possible if the client is doing something unusual with `context.device`.\n *\n * @return {{type: string}}\n */\nf.device = function() {\n  let device = this.proxy(\"context.device\");\n  if (typeof device !== \"object\" || device === null) {\n    device = {};\n  }\n  let library = this.library().name;\n  if (device.type) return device;\n\n  if (library.indexOf(\"ios\") > -1) device.type = \"ios\";\n  if (library.indexOf(\"android\") > -1) device.type = \"android\";\n  return device;\n};\n\n/**\n * Get the User-Agent from `context.userAgent`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return string\n */\nf.userAgent = Facade.proxy(\"context.userAgent\");\n\n/**\n * Get the timezone from `context.timezone`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return string\n */\nf.timezone = Facade.proxy(\"context.timezone\");\n\n/**\n * Get the timestamp from `context.timestamp`.\n *\n * @function\n * @return string\n */\nf.timestamp = Facade.field(\"timestamp\");\n\n/**\n * Get the channel from `channel`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return string\n */\nf.channel = Facade.field(\"channel\");\n\n/**\n * Get the IP address from `context.ip`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return string\n */\nf.ip = Facade.proxy(\"context.ip\");\n\n/**\n * Get the user ID from `userId`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return string\n */\nf.userId = Facade.field(\"userId\");\n\n/**\n * Get the ZIP/Postal code from `traits`, `traits.address`, `properties`, or\n * `properties.address`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @name zip\n * @function\n * @memberof f\n * @return {string}\n */\n\n/**\n * Get the country from `traits`, `traits.address`, `properties`, or\n * `properties.address`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @name country\n * @function\n * @memberof f\n * @return {string}\n */\n\n/**\n * Get the street from `traits`, `traits.address`, `properties`, or\n * `properties.address`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @name street\n * @function\n * @memberof f\n * @return {string}\n */\n\n/**\n * Get the state from `traits`, `traits.address`, `properties`, or\n * `properties.address`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @name state\n * @function\n * @memberof f\n * @return {string}\n */\n\n/**\n * Get the city from `traits`, `traits.address`, `properties`, or\n * `properties.address`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @name city\n * @function\n * @memberof f\n * @return {string}\n */\n\n/**\n * Get the region from `traits`, `traits.address`, `properties`, or\n * `properties.address`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @name region\n * @function\n * @memberof f\n * @return {string}\n */\n\naddress(f);\n\n/**\n * Return the cloned and traversed object\n *\n * @ignore\n * @param {*} obj\n * @return {*}\n */\nfunction transform (obj) {\n  return clone(obj);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}