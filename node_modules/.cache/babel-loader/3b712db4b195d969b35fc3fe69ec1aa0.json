{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar dlv_1 = __importDefault(require(\"dlv\"));\n\nfunction matches(event, matcher) {\n  if (!matcher) {\n    throw new Error('No matcher supplied!');\n  }\n\n  switch (matcher.type) {\n    case 'all':\n      return all();\n\n    case 'fql':\n      return fql(matcher.ir, event);\n\n    default:\n      throw new Error(\"Matcher of type \".concat(matcher.type, \" unsupported.\"));\n  }\n}\n\nexports.default = matches;\n\nfunction all() {\n  return true;\n}\n\nfunction fql(ir, event) {\n  if (!ir) {\n    return false;\n  }\n\n  try {\n    ir = JSON.parse(ir);\n  } catch (e) {\n    throw new Error(\"Failed to JSON.parse FQL intermediate representation \\\"\".concat(ir, \"\\\": \").concat(e));\n  }\n\n  var result = fqlEvaluate(ir, event);\n\n  if (typeof result !== 'boolean') {\n    // An error was returned, or a lowercase, typeof, or similar function was run alone. Nothing to evaluate.\n    return false;\n  }\n\n  return result;\n} // FQL is 100% type strict in Go. Show no mercy to types which do not comply.\n\n\nfunction fqlEvaluate(ir, event) {\n  // If the given ir chunk is not an array, then we should check the single given path or value for literally `true`.\n  if (!Array.isArray(ir)) {\n    return getValue(ir, event) === true;\n  } // Otherwise, it is a sequence of ordered steps to follow to reach our solution!\n\n\n  var item = ir[0];\n\n  switch (item) {\n    /*** Unary cases ***/\n    // '!' => Invert the result\n    case '!':\n      return !fqlEvaluate(ir[1], event);\n\n    /*** Binary cases ***/\n    // 'or' => Any condition being true returns true\n\n    case 'or':\n      for (var i = 1; i < ir.length; i++) {\n        if (fqlEvaluate(ir[i], event)) {\n          return true;\n        }\n      }\n\n      return false;\n    // 'and' => Any condition being false returns false\n\n    case 'and':\n      for (var i = 1; i < ir.length; i++) {\n        if (!fqlEvaluate(ir[i], event)) {\n          return false;\n        }\n      }\n\n      return true;\n    // Equivalence comparisons\n\n    case '=':\n    case '!=':\n      return compareItems(getValue(ir[1], event), getValue(ir[2], event), item, event);\n    // Numerical comparisons\n\n    case '<=':\n    case '<':\n    case '>':\n    case '>=':\n      // Compare the two values with the given operator.\n      return compareNumbers(getValue(ir[1], event), getValue(ir[2], event), item, event);\n\n    /*** Functions ***/\n    // 'contains(str1, str2)' => The first string has a substring of the second string\n\n    case 'contains':\n      return contains(getValue(ir[1], event), getValue(ir[2], event));\n    // 'match(str, match)' => The given string matches the provided glob matcher\n\n    case 'match':\n      return match(getValue(ir[1], event), getValue(ir[2], event));\n    // 'lowercase(str)' => Returns a lowercased string, null if the item is not a string\n\n    case 'lowercase':\n      var target = getValue(ir[1], event);\n\n      if (typeof target !== 'string') {\n        return null;\n      }\n\n      return target.toLowerCase();\n    // 'typeof(val)' => Returns the FQL type of the value\n\n    case 'typeof':\n      // TODO: Do we need mapping to allow for universal comparisons? e.g. Object -> JSON, Array -> List, Floats?\n      return typeof getValue(ir[1], event);\n    // 'length(val)' => Returns the length of an array or string, NaN if neither\n\n    case 'length':\n      return length(getValue(ir[1], event));\n    // If nothing hit, we or the IR messed up somewhere.\n\n    default:\n      throw new Error(\"FQL IR could not evaluate for token: \".concat(item));\n  }\n}\n\nfunction getValue(item, event) {\n  // If item is an array, leave it as-is.\n  if (Array.isArray(item)) {\n    return item;\n  } // If item is an object, it has the form of `{\"value\": VAL}`\n\n\n  if (typeof item === 'object') {\n    return item.value;\n  } // Otherwise, it's an event path, e.g. \"properties.email\"\n\n\n  return (0, dlv_1.default)(event, item);\n}\n\nfunction compareNumbers(first, second, operator, event) {\n  // Check if it's more IR (such as a length() function)\n  if (isIR(first)) {\n    first = fqlEvaluate(first, event);\n  }\n\n  if (isIR(second)) {\n    second = fqlEvaluate(second, event);\n  }\n\n  if (typeof first !== 'number' || typeof second !== 'number') {\n    return false;\n  } // Reminder: NaN is not comparable to any other number (including NaN) and will always return false as desired.\n\n\n  switch (operator) {\n    // '<=' => The first number is less than or equal to the second.\n    case '<=':\n      return first <= second;\n    // '>=' => The first number is greater than or equal to the second\n\n    case '>=':\n      return first >= second;\n    // '<' The first number is less than the second.\n\n    case '<':\n      return first < second;\n    // '>' The first number is greater than the second.\n\n    case '>':\n      return first > second;\n\n    default:\n      throw new Error(\"Invalid operator in compareNumbers: \".concat(operator));\n  }\n}\n\nfunction compareItems(first, second, operator, event) {\n  // Check if it's more IR (such as a lowercase() function)\n  if (isIR(first)) {\n    first = fqlEvaluate(first, event);\n  }\n\n  if (isIR(second)) {\n    second = fqlEvaluate(second, event);\n  }\n\n  if (typeof first === 'object' && typeof second === 'object') {\n    first = JSON.stringify(first);\n    second = JSON.stringify(second);\n  } // Objects with the exact same contents AND order ARE considered identical. (Don't compare by reference)\n  // Even in Go, this MUST be the same byte order.\n  // e.g. {a: 1, b:2} === {a: 1, b:2} BUT {a:1, b:2} !== {b:2, a:1}\n  // Maybe later we'll use a stable stringifier, but we're matching server-side behavior for now.\n\n\n  switch (operator) {\n    // '=' => The two following items are exactly identical\n    case '=':\n      return first === second;\n    // '!=' => The two following items are NOT exactly identical.\n\n    case '!=':\n      return first !== second;\n\n    default:\n      throw new Error(\"Invalid operator in compareItems: \".concat(operator));\n  }\n}\n\nfunction contains(first, second) {\n  if (typeof first !== 'string' || typeof second !== 'string') {\n    return false;\n  }\n\n  return first.indexOf(second) !== -1;\n}\n\nfunction match(str, glob) {\n  if (typeof str !== 'string' || typeof glob !== 'string') {\n    return false;\n  }\n\n  return globMatches(glob, str);\n}\n\nfunction length(item) {\n  // Match server-side behavior.\n  if (item === null) {\n    return 0;\n  } // Type-check to avoid returning .length of an object\n\n\n  if (!Array.isArray(item) && typeof item !== 'string') {\n    return NaN;\n  }\n\n  return item.length;\n} // This is a heuristic technically speaking, but should be close enough. The odds of someone trying to test\n// a func with identical IR notation is pretty low.\n\n\nfunction isIR(value) {\n  // TODO: This can be better checked by checking if this is a {\"value\": THIS}\n  if (!Array.isArray(value)) {\n    return false;\n  } // Function checks\n\n\n  if ((value[0] === 'lowercase' || value[0] === 'length' || value[0] === 'typeof') && value.length === 2) {\n    return true;\n  }\n\n  if ((value[0] === 'contains' || value[0] === 'match') && value.length === 3) {\n    return true;\n  }\n\n  return false;\n} // Any reputable glob matcher is designed to work on filesystems and doesn't allow the override of the separator\n// character \"/\". This is problematic since our server-side representation e.g. evaluates \"match('ab/c', 'a*)\"\n// as TRUE, whereas any glob matcher for JS available does false. So we're rewriting it here.\n// See: https://github.com/segmentio/glob/blob/master/glob.go\n\n\nfunction globMatches(pattern, str) {\n  var _a, _b;\n\n  Pattern: while (pattern.length > 0) {\n    var star = void 0;\n    var chunk = void 0;\n    _a = scanChunk(pattern), star = _a.star, chunk = _a.chunk, pattern = _a.pattern;\n\n    if (star && chunk === '') {\n      // Trailing * matches rest of string\n      return true;\n    } // Look for match at current position\n\n\n    var _c = matchChunk(chunk, str),\n        t = _c.t,\n        ok = _c.ok,\n        err = _c.err;\n\n    if (err) {\n      return false;\n    } // If we're the last chunk, make sure we've exhausted the str\n    // otherwise we'll give a false result even if we could still match\n    // using the star\n\n\n    if (ok && (t.length === 0 || pattern.length > 0)) {\n      str = t;\n      continue;\n    }\n\n    if (star) {\n      // Look for match, skipping i+1 bytes.\n      for (var i = 0; i < str.length; i++) {\n        ;\n        _b = matchChunk(chunk, str.slice(i + 1)), t = _b.t, ok = _b.ok, err = _b.err;\n\n        if (ok) {\n          // If we're the last chunk, make sure we exhausted the str.\n          if (pattern.length === 0 && t.length > 0) {\n            continue;\n          }\n\n          str = t;\n          continue Pattern;\n        }\n\n        if (err) {\n          return false;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  return str.length === 0;\n}\n\nfunction scanChunk(pattern) {\n  var result = {\n    star: false,\n    chunk: '',\n    pattern: ''\n  };\n\n  while (pattern.length > 0 && pattern[0] === '*') {\n    pattern = pattern.slice(1);\n    result.star = true;\n  }\n\n  var inRange = false;\n  var i;\n\n  Scan: for (i = 0; i < pattern.length; i++) {\n    switch (pattern[i]) {\n      case '\\\\':\n        // Error check handled in matchChunk: bad pattern.\n        if (i + 1 < pattern.length) {\n          i++;\n        }\n\n        break;\n\n      case '[':\n        inRange = true;\n        break;\n\n      case ']':\n        inRange = false;\n        break;\n\n      case '*':\n        if (!inRange) {\n          break Scan;\n        }\n\n    }\n  }\n\n  result.chunk = pattern.slice(0, i);\n  result.pattern = pattern.slice(i);\n  return result;\n} // matchChunk checks whether chunk matches the beginning of s.\n// If so, it returns the remainder of s (after the match).\n// Chunk is all single-character operators: literals, char classes, and ?.\n\n\nfunction matchChunk(chunk, str) {\n  var _a, _b;\n\n  var result = {\n    t: '',\n    ok: false,\n    err: false\n  };\n\n  while (chunk.length > 0) {\n    if (str.length === 0) {\n      return result;\n    }\n\n    switch (chunk[0]) {\n      case '[':\n        var char = str[0];\n        str = str.slice(1);\n        chunk = chunk.slice(1);\n        var notNegated = true;\n\n        if (chunk.length > 0 && chunk[0] === '^') {\n          notNegated = false;\n          chunk = chunk.slice(1);\n        } // Parse all ranges\n\n\n        var foundMatch = false;\n        var nRange = 0;\n\n        while (true) {\n          if (chunk.length > 0 && chunk[0] === ']' && nRange > 0) {\n            chunk = chunk.slice(1);\n            break;\n          }\n\n          var lo = '';\n          var hi = '';\n          var err = void 0;\n          _a = getEsc(chunk), lo = _a.char, chunk = _a.newChunk, err = _a.err;\n\n          if (err) {\n            return result;\n          }\n\n          hi = lo;\n\n          if (chunk[0] === '-') {\n            ;\n            _b = getEsc(chunk.slice(1)), hi = _b.char, chunk = _b.newChunk, err = _b.err;\n\n            if (err) {\n              return result;\n            }\n          }\n\n          if (lo <= char && char <= hi) {\n            foundMatch = true;\n          }\n\n          nRange++;\n        }\n\n        if (foundMatch !== notNegated) {\n          return result;\n        }\n\n        break;\n\n      case '?':\n        str = str.slice(1);\n        chunk = chunk.slice(1);\n        break;\n\n      case '\\\\':\n        chunk = chunk.slice(1);\n\n        if (chunk.length === 0) {\n          result.err = true;\n          return result;\n        }\n\n      // Fallthrough, missing break intentional.\n\n      default:\n        if (chunk[0] !== str[0]) {\n          return result;\n        }\n\n        str = str.slice(1);\n        chunk = chunk.slice(1);\n    }\n  }\n\n  result.t = str;\n  result.ok = true;\n  result.err = false;\n  return result;\n} // getEsc gets a possibly-escaped character from chunk, for a character class.\n\n\nfunction getEsc(chunk) {\n  var result = {\n    char: '',\n    newChunk: '',\n    err: false\n  };\n\n  if (chunk.length === 0 || chunk[0] === '-' || chunk[0] === ']') {\n    result.err = true;\n    return result;\n  }\n\n  if (chunk[0] === '\\\\') {\n    chunk = chunk.slice(1);\n\n    if (chunk.length === 0) {\n      result.err = true;\n      return result;\n    }\n  } // Unlike Go, JS strings operate on characters instead of bytes.\n  // This is why we aren't copying over the GetRuneFromString stuff.\n\n\n  result.char = chunk[0];\n  result.newChunk = chunk.slice(1);\n\n  if (result.newChunk.length === 0) {\n    result.err = true;\n  }\n\n  return result;\n}","map":{"version":3,"sources":["../src/matchers.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar dlv_1 = __importDefault(require(\"dlv\"));\nfunction matches(event, matcher) {\n    if (!matcher) {\n        throw new Error('No matcher supplied!');\n    }\n    switch (matcher.type) {\n        case 'all':\n            return all();\n        case 'fql':\n            return fql(matcher.ir, event);\n        default:\n            throw new Error(\"Matcher of type \".concat(matcher.type, \" unsupported.\"));\n    }\n}\nexports.default = matches;\nfunction all() {\n    return true;\n}\nfunction fql(ir, event) {\n    if (!ir) {\n        return false;\n    }\n    try {\n        ir = JSON.parse(ir);\n    }\n    catch (e) {\n        throw new Error(\"Failed to JSON.parse FQL intermediate representation \\\"\".concat(ir, \"\\\": \").concat(e));\n    }\n    var result = fqlEvaluate(ir, event);\n    if (typeof result !== 'boolean') {\n        // An error was returned, or a lowercase, typeof, or similar function was run alone. Nothing to evaluate.\n        return false;\n    }\n    return result;\n}\n// FQL is 100% type strict in Go. Show no mercy to types which do not comply.\nfunction fqlEvaluate(ir, event) {\n    // If the given ir chunk is not an array, then we should check the single given path or value for literally `true`.\n    if (!Array.isArray(ir)) {\n        return getValue(ir, event) === true;\n    }\n    // Otherwise, it is a sequence of ordered steps to follow to reach our solution!\n    var item = ir[0];\n    switch (item) {\n        /*** Unary cases ***/\n        // '!' => Invert the result\n        case '!':\n            return !fqlEvaluate(ir[1], event);\n        /*** Binary cases ***/\n        // 'or' => Any condition being true returns true\n        case 'or':\n            for (var i = 1; i < ir.length; i++) {\n                if (fqlEvaluate(ir[i], event)) {\n                    return true;\n                }\n            }\n            return false;\n        // 'and' => Any condition being false returns false\n        case 'and':\n            for (var i = 1; i < ir.length; i++) {\n                if (!fqlEvaluate(ir[i], event)) {\n                    return false;\n                }\n            }\n            return true;\n        // Equivalence comparisons\n        case '=':\n        case '!=':\n            return compareItems(getValue(ir[1], event), getValue(ir[2], event), item, event);\n        // Numerical comparisons\n        case '<=':\n        case '<':\n        case '>':\n        case '>=':\n            // Compare the two values with the given operator.\n            return compareNumbers(getValue(ir[1], event), getValue(ir[2], event), item, event);\n        /*** Functions ***/\n        // 'contains(str1, str2)' => The first string has a substring of the second string\n        case 'contains':\n            return contains(getValue(ir[1], event), getValue(ir[2], event));\n        // 'match(str, match)' => The given string matches the provided glob matcher\n        case 'match':\n            return match(getValue(ir[1], event), getValue(ir[2], event));\n        // 'lowercase(str)' => Returns a lowercased string, null if the item is not a string\n        case 'lowercase':\n            var target = getValue(ir[1], event);\n            if (typeof target !== 'string') {\n                return null;\n            }\n            return target.toLowerCase();\n        // 'typeof(val)' => Returns the FQL type of the value\n        case 'typeof':\n            // TODO: Do we need mapping to allow for universal comparisons? e.g. Object -> JSON, Array -> List, Floats?\n            return typeof getValue(ir[1], event);\n        // 'length(val)' => Returns the length of an array or string, NaN if neither\n        case 'length':\n            return length(getValue(ir[1], event));\n        // If nothing hit, we or the IR messed up somewhere.\n        default:\n            throw new Error(\"FQL IR could not evaluate for token: \".concat(item));\n    }\n}\nfunction getValue(item, event) {\n    // If item is an array, leave it as-is.\n    if (Array.isArray(item)) {\n        return item;\n    }\n    // If item is an object, it has the form of `{\"value\": VAL}`\n    if (typeof item === 'object') {\n        return item.value;\n    }\n    // Otherwise, it's an event path, e.g. \"properties.email\"\n    return (0, dlv_1.default)(event, item);\n}\nfunction compareNumbers(first, second, operator, event) {\n    // Check if it's more IR (such as a length() function)\n    if (isIR(first)) {\n        first = fqlEvaluate(first, event);\n    }\n    if (isIR(second)) {\n        second = fqlEvaluate(second, event);\n    }\n    if (typeof first !== 'number' || typeof second !== 'number') {\n        return false;\n    }\n    // Reminder: NaN is not comparable to any other number (including NaN) and will always return false as desired.\n    switch (operator) {\n        // '<=' => The first number is less than or equal to the second.\n        case '<=':\n            return first <= second;\n        // '>=' => The first number is greater than or equal to the second\n        case '>=':\n            return first >= second;\n        // '<' The first number is less than the second.\n        case '<':\n            return first < second;\n        // '>' The first number is greater than the second.\n        case '>':\n            return first > second;\n        default:\n            throw new Error(\"Invalid operator in compareNumbers: \".concat(operator));\n    }\n}\nfunction compareItems(first, second, operator, event) {\n    // Check if it's more IR (such as a lowercase() function)\n    if (isIR(first)) {\n        first = fqlEvaluate(first, event);\n    }\n    if (isIR(second)) {\n        second = fqlEvaluate(second, event);\n    }\n    if (typeof first === 'object' && typeof second === 'object') {\n        first = JSON.stringify(first);\n        second = JSON.stringify(second);\n    }\n    // Objects with the exact same contents AND order ARE considered identical. (Don't compare by reference)\n    // Even in Go, this MUST be the same byte order.\n    // e.g. {a: 1, b:2} === {a: 1, b:2} BUT {a:1, b:2} !== {b:2, a:1}\n    // Maybe later we'll use a stable stringifier, but we're matching server-side behavior for now.\n    switch (operator) {\n        // '=' => The two following items are exactly identical\n        case '=':\n            return first === second;\n        // '!=' => The two following items are NOT exactly identical.\n        case '!=':\n            return first !== second;\n        default:\n            throw new Error(\"Invalid operator in compareItems: \".concat(operator));\n    }\n}\nfunction contains(first, second) {\n    if (typeof first !== 'string' || typeof second !== 'string') {\n        return false;\n    }\n    return first.indexOf(second) !== -1;\n}\nfunction match(str, glob) {\n    if (typeof str !== 'string' || typeof glob !== 'string') {\n        return false;\n    }\n    return globMatches(glob, str);\n}\nfunction length(item) {\n    // Match server-side behavior.\n    if (item === null) {\n        return 0;\n    }\n    // Type-check to avoid returning .length of an object\n    if (!Array.isArray(item) && typeof item !== 'string') {\n        return NaN;\n    }\n    return item.length;\n}\n// This is a heuristic technically speaking, but should be close enough. The odds of someone trying to test\n// a func with identical IR notation is pretty low.\nfunction isIR(value) {\n    // TODO: This can be better checked by checking if this is a {\"value\": THIS}\n    if (!Array.isArray(value)) {\n        return false;\n    }\n    // Function checks\n    if ((value[0] === 'lowercase' || value[0] === 'length' || value[0] === 'typeof') &&\n        value.length === 2) {\n        return true;\n    }\n    if ((value[0] === 'contains' || value[0] === 'match') && value.length === 3) {\n        return true;\n    }\n    return false;\n}\n// Any reputable glob matcher is designed to work on filesystems and doesn't allow the override of the separator\n// character \"/\". This is problematic since our server-side representation e.g. evaluates \"match('ab/c', 'a*)\"\n// as TRUE, whereas any glob matcher for JS available does false. So we're rewriting it here.\n// See: https://github.com/segmentio/glob/blob/master/glob.go\nfunction globMatches(pattern, str) {\n    var _a, _b;\n    Pattern: while (pattern.length > 0) {\n        var star = void 0;\n        var chunk = void 0;\n        (_a = scanChunk(pattern), star = _a.star, chunk = _a.chunk, pattern = _a.pattern);\n        if (star && chunk === '') {\n            // Trailing * matches rest of string\n            return true;\n        }\n        // Look for match at current position\n        var _c = matchChunk(chunk, str), t = _c.t, ok = _c.ok, err = _c.err;\n        if (err) {\n            return false;\n        }\n        // If we're the last chunk, make sure we've exhausted the str\n        // otherwise we'll give a false result even if we could still match\n        // using the star\n        if (ok && (t.length === 0 || pattern.length > 0)) {\n            str = t;\n            continue;\n        }\n        if (star) {\n            // Look for match, skipping i+1 bytes.\n            for (var i = 0; i < str.length; i++) {\n                ;\n                (_b = matchChunk(chunk, str.slice(i + 1)), t = _b.t, ok = _b.ok, err = _b.err);\n                if (ok) {\n                    // If we're the last chunk, make sure we exhausted the str.\n                    if (pattern.length === 0 && t.length > 0) {\n                        continue;\n                    }\n                    str = t;\n                    continue Pattern;\n                }\n                if (err) {\n                    return false;\n                }\n            }\n        }\n        return false;\n    }\n    return str.length === 0;\n}\nfunction scanChunk(pattern) {\n    var result = {\n        star: false,\n        chunk: '',\n        pattern: '',\n    };\n    while (pattern.length > 0 && pattern[0] === '*') {\n        pattern = pattern.slice(1);\n        result.star = true;\n    }\n    var inRange = false;\n    var i;\n    Scan: for (i = 0; i < pattern.length; i++) {\n        switch (pattern[i]) {\n            case '\\\\':\n                // Error check handled in matchChunk: bad pattern.\n                if (i + 1 < pattern.length) {\n                    i++;\n                }\n                break;\n            case '[':\n                inRange = true;\n                break;\n            case ']':\n                inRange = false;\n                break;\n            case '*':\n                if (!inRange) {\n                    break Scan;\n                }\n        }\n    }\n    result.chunk = pattern.slice(0, i);\n    result.pattern = pattern.slice(i);\n    return result;\n}\n// matchChunk checks whether chunk matches the beginning of s.\n// If so, it returns the remainder of s (after the match).\n// Chunk is all single-character operators: literals, char classes, and ?.\nfunction matchChunk(chunk, str) {\n    var _a, _b;\n    var result = {\n        t: '',\n        ok: false,\n        err: false,\n    };\n    while (chunk.length > 0) {\n        if (str.length === 0) {\n            return result;\n        }\n        switch (chunk[0]) {\n            case '[':\n                var char = str[0];\n                str = str.slice(1);\n                chunk = chunk.slice(1);\n                var notNegated = true;\n                if (chunk.length > 0 && chunk[0] === '^') {\n                    notNegated = false;\n                    chunk = chunk.slice(1);\n                }\n                // Parse all ranges\n                var foundMatch = false;\n                var nRange = 0;\n                while (true) {\n                    if (chunk.length > 0 && chunk[0] === ']' && nRange > 0) {\n                        chunk = chunk.slice(1);\n                        break;\n                    }\n                    var lo = '';\n                    var hi = '';\n                    var err = void 0;\n                    (_a = getEsc(chunk), lo = _a.char, chunk = _a.newChunk, err = _a.err);\n                    if (err) {\n                        return result;\n                    }\n                    hi = lo;\n                    if (chunk[0] === '-') {\n                        ;\n                        (_b = getEsc(chunk.slice(1)), hi = _b.char, chunk = _b.newChunk, err = _b.err);\n                        if (err) {\n                            return result;\n                        }\n                    }\n                    if (lo <= char && char <= hi) {\n                        foundMatch = true;\n                    }\n                    nRange++;\n                }\n                if (foundMatch !== notNegated) {\n                    return result;\n                }\n                break;\n            case '?':\n                str = str.slice(1);\n                chunk = chunk.slice(1);\n                break;\n            case '\\\\':\n                chunk = chunk.slice(1);\n                if (chunk.length === 0) {\n                    result.err = true;\n                    return result;\n                }\n            // Fallthrough, missing break intentional.\n            default:\n                if (chunk[0] !== str[0]) {\n                    return result;\n                }\n                str = str.slice(1);\n                chunk = chunk.slice(1);\n        }\n    }\n    result.t = str;\n    result.ok = true;\n    result.err = false;\n    return result;\n}\n// getEsc gets a possibly-escaped character from chunk, for a character class.\nfunction getEsc(chunk) {\n    var result = {\n        char: '',\n        newChunk: '',\n        err: false,\n    };\n    if (chunk.length === 0 || chunk[0] === '-' || chunk[0] === ']') {\n        result.err = true;\n        return result;\n    }\n    if (chunk[0] === '\\\\') {\n        chunk = chunk.slice(1);\n        if (chunk.length === 0) {\n            result.err = true;\n            return result;\n        }\n    }\n    // Unlike Go, JS strings operate on characters instead of bytes.\n    // This is why we aren't copying over the GetRuneFromString stuff.\n    result.char = chunk[0];\n    result.newChunk = chunk.slice(1);\n    if (result.newChunk.length === 0) {\n        result.err = true;\n    }\n    return result;\n}\n//# sourceMappingURL=matchers.js.map"]},"metadata":{},"sourceType":"script"}