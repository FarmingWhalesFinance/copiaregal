{"ast":null,"code":"import { ethers } from \"ethers\";\nimport { getProvider, getFallbackProvider } from \"src/Helpers\";\nexport const contractFetcher = (library, contractInfo, additionalArgs) => function () {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  // eslint-disable-next-line\n  const [id, chainId, arg0, arg1, ...params] = args;\n  const provider = getProvider(library, chainId);\n  const method = ethers.utils.isAddress(arg0) ? arg1 : arg0;\n  const contractCall = getContractCall({\n    provider,\n    contractInfo,\n    arg0,\n    arg1,\n    method,\n    params,\n    additionalArgs\n  });\n  let shouldCallFallback = true;\n\n  const handleFallback = async (resolve, reject, error) => {\n    if (!shouldCallFallback) {\n      return;\n    } // prevent fallback from being called twice\n\n\n    shouldCallFallback = false;\n    const fallbackProvider = getFallbackProvider(chainId);\n\n    if (!fallbackProvider) {\n      reject(error);\n      return;\n    }\n\n    console.info(\"using fallbackProvider for\", method);\n    const fallbackContractCall = getContractCall({\n      provider: fallbackProvider,\n      contractInfo,\n      arg0,\n      arg1,\n      method,\n      params,\n      additionalArgs\n    });\n    fallbackContractCall.then(result => resolve(result)).catch(e => {\n      console.error(\"fallback fetcher error\", id, contractInfo.contractName, method, e);\n      reject(e);\n    });\n  };\n\n  return new Promise(async (resolve, reject) => {\n    contractCall.then(result => {\n      shouldCallFallback = false;\n      resolve(result);\n    }).catch(e => {\n      console.error(\"fetcher error\", id, contractInfo.contractName, method, e);\n      handleFallback(resolve, reject, e);\n    });\n    setTimeout(() => {\n      handleFallback(resolve, reject, \"contractCall timeout\");\n    }, 2000);\n  });\n};\n\nfunction getContractCall(_ref) {\n  let {\n    provider,\n    contractInfo,\n    arg0,\n    arg1,\n    method,\n    params,\n    additionalArgs\n  } = _ref;\n\n  if (ethers.utils.isAddress(arg0)) {\n    const address = arg0;\n    const contract = new ethers.Contract(address, contractInfo.abi, provider);\n\n    if (additionalArgs) {\n      return contract[method](...params.concat(additionalArgs));\n    }\n\n    return contract[method](...params);\n  }\n\n  if (!provider) {\n    return;\n  }\n\n  return provider[method](arg1, ...params);\n}","map":{"version":3,"names":["ethers","getProvider","getFallbackProvider","contractFetcher","library","contractInfo","additionalArgs","args","id","chainId","arg0","arg1","params","provider","method","utils","isAddress","contractCall","getContractCall","shouldCallFallback","handleFallback","resolve","reject","error","fallbackProvider","console","info","fallbackContractCall","then","result","catch","e","contractName","Promise","setTimeout","address","contract","Contract","abi","concat"],"sources":["C:/Users/rober/Documents/swaps-client/src/lib/swr/contractFetcher.ts"],"sourcesContent":["import { ethers } from \"ethers\";\nimport { Web3Provider } from \"@ethersproject/providers\";\nimport { getProvider, getFallbackProvider } from \"src/Helpers\";\n\nexport const contractFetcher =\n  <T>(library: Web3Provider, contractInfo: any, additionalArgs: any[]) =>\n  (...args: any): Promise<T> => {\n    // eslint-disable-next-line\n    const [id, chainId, arg0, arg1, ...params] = args;\n    const provider = getProvider(library, chainId);\n\n    const method = ethers.utils.isAddress(arg0) ? arg1 : arg0;\n\n    const contractCall = getContractCall({\n      provider,\n      contractInfo,\n      arg0,\n      arg1,\n      method,\n      params,\n      additionalArgs,\n    });\n\n    let shouldCallFallback = true;\n\n    const handleFallback = async (resolve, reject, error) => {\n      if (!shouldCallFallback) {\n        return;\n      }\n      // prevent fallback from being called twice\n      shouldCallFallback = false;\n\n      const fallbackProvider = getFallbackProvider(chainId);\n      if (!fallbackProvider) {\n        reject(error);\n        return;\n      }\n\n      console.info(\"using fallbackProvider for\", method);\n      const fallbackContractCall = getContractCall({\n        provider: fallbackProvider,\n        contractInfo,\n        arg0,\n        arg1,\n        method,\n        params,\n        additionalArgs,\n      });\n\n      fallbackContractCall\n        .then((result) => resolve(result))\n        .catch((e) => {\n          console.error(\"fallback fetcher error\", id, contractInfo.contractName, method, e);\n          reject(e);\n        });\n    };\n\n    return new Promise(async (resolve, reject) => {\n      contractCall\n        .then((result) => {\n          shouldCallFallback = false;\n          resolve(result);\n        })\n        .catch((e) => {\n          console.error(\"fetcher error\", id, contractInfo.contractName, method, e);\n          handleFallback(resolve, reject, e);\n        });\n\n      setTimeout(() => {\n        handleFallback(resolve, reject, \"contractCall timeout\");\n      }, 2000);\n    });\n  };\n\nfunction getContractCall({ provider, contractInfo, arg0, arg1, method, params, additionalArgs }) {\n  if (ethers.utils.isAddress(arg0)) {\n    const address = arg0;\n    const contract = new ethers.Contract(address, contractInfo.abi, provider);\n\n    if (additionalArgs) {\n      return contract[method](...params.concat(additionalArgs));\n    }\n    return contract[method](...params);\n  }\n\n  if (!provider) {\n    return;\n  }\n\n  return provider[method](arg1, ...params);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}