{"ast":null,"code":"import { asPromise } from '../../lib/as-promise';\nexport function pTimeout(cb, timeout) {\n  return new Promise(function (resolve, reject) {\n    var timeoutId = setTimeout(function () {\n      reject(Error('Promise timed out'));\n    }, timeout);\n    cb.then(function (val) {\n      clearTimeout(timeoutId);\n      return resolve(val);\n    }).catch(reject);\n  });\n}\n\nfunction sleep(timeoutInMs) {\n  return new Promise(function (resolve) {\n    return setTimeout(resolve, timeoutInMs);\n  });\n}\n/**\n * @param delayTimeout - The amount of time in ms to wait before invoking the callback.\n * @param timeout - The maximum amount of time in ms to allow the callback to run for.\n */\n\n\nexport function invokeCallback(ctx, callback, delayTimeout, timeout) {\n  var cb = function () {\n    try {\n      return asPromise(callback(ctx));\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  };\n\n  return sleep(delayTimeout) // pTimeout ensures that the callback can't cause the context to hang\n  .then(function () {\n    return pTimeout(cb(), timeout !== null && timeout !== void 0 ? timeout : 1000);\n  }).catch(function (err) {\n    ctx === null || ctx === void 0 ? void 0 : ctx.log('warn', 'Callback Error', {\n      error: err\n    });\n    ctx === null || ctx === void 0 ? void 0 : ctx.stats.increment('callback_error');\n  }).then(function () {\n    return ctx;\n  });\n}","map":{"version":3,"sources":["../../../../src/core/callback/index.ts"],"names":[],"mappings":"AACA,SAAS,SAAT,QAA0B,sBAA1B;AAGA,OAAM,SAAU,QAAV,CACJ,EADI,EAEJ,OAFI,EAEW;EAEf,OAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAgB;IACjC,IAAM,SAAS,GAAG,UAAU,CAAC,YAAA;MAC3B,MAAM,CAAC,KAAK,CAAC,mBAAD,CAAN,CAAN;IACD,CAF2B,EAEzB,OAFyB,CAA5B;IAIA,EAAE,CAAC,IAAH,CAAQ,UAAC,GAAD,EAAI;MACV,YAAY,CAAC,SAAD,CAAZ;MACA,OAAO,OAAO,CAAC,GAAD,CAAd;IACD,CAHD,EAGG,KAHH,CAGS,MAHT;EAID,CATM,CAAP;AAUD;;AAED,SAAS,KAAT,CAAe,WAAf,EAAkC;EAChC,OAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAQ;IAAK,OAAA,UAAU,CAAC,OAAD,EAAV,WAAU,CAAV;EAAgC,CAAzD,CAAP;AACD;AAED;;;AAGG;;;AACH,OAAM,SAAU,cAAV,CACJ,GADI,EAEJ,QAFI,EAGJ,YAHI,EAIJ,OAJI,EAIY;EAEhB,IAAM,EAAE,GAAG,YAAA;IACT,IAAI;MACF,OAAO,SAAS,CAAC,QAAQ,CAAC,GAAD,CAAT,CAAhB;IACD,CAFD,CAEE,OAAO,GAAP,EAAY;MACZ,OAAO,OAAO,CAAC,MAAR,CAAe,GAAf,CAAP;IACD;EACF,CAND;;EAQA,OACE,KAAK,CAAC,YAAD,CAAL,CACE;EADF,CAEG,IAFH,CAEQ,YAAA;IAAM,OAAA,QAAQ,CAAC,EAAE,EAAH,EAAO,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAA,OAAA,GAAf,IAAQ,CAAR;EAA+B,CAF7C,EAGG,KAHH,CAGS,UAAC,GAAD,EAAI;IACT,GAAG,KAAA,IAAH,IAAA,GAAG,KAAA,KAAA,CAAH,GAAG,KAAA,CAAH,GAAA,GAAG,CAAE,GAAL,CAAS,MAAT,EAAiB,gBAAjB,EAAmC;MAAE,KAAK,EAAE;IAAT,CAAnC,CAAA;IACA,GAAG,KAAA,IAAH,IAAA,GAAG,KAAA,KAAA,CAAH,GAAG,KAAA,CAAH,GAAA,GAAG,CAAE,KAAL,CAAW,SAAX,CAAqB,gBAArB,CAAA;EACD,CANH,EAOG,IAPH,CAOQ,YAAA;IAAM,OAAA,GAAA;EAAG,CAPjB,CADF;AAUD","sourceRoot":"","sourcesContent":["import { asPromise } from '../../lib/as-promise';\nexport function pTimeout(cb, timeout) {\n    return new Promise(function (resolve, reject) {\n        var timeoutId = setTimeout(function () {\n            reject(Error('Promise timed out'));\n        }, timeout);\n        cb.then(function (val) {\n            clearTimeout(timeoutId);\n            return resolve(val);\n        }).catch(reject);\n    });\n}\nfunction sleep(timeoutInMs) {\n    return new Promise(function (resolve) { return setTimeout(resolve, timeoutInMs); });\n}\n/**\n * @param delayTimeout - The amount of time in ms to wait before invoking the callback.\n * @param timeout - The maximum amount of time in ms to allow the callback to run for.\n */\nexport function invokeCallback(ctx, callback, delayTimeout, timeout) {\n    var cb = function () {\n        try {\n            return asPromise(callback(ctx));\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    };\n    return (sleep(delayTimeout)\n        // pTimeout ensures that the callback can't cause the context to hang\n        .then(function () { return pTimeout(cb(), timeout !== null && timeout !== void 0 ? timeout : 1000); })\n        .catch(function (err) {\n        ctx === null || ctx === void 0 ? void 0 : ctx.log('warn', 'Callback Error', { error: err });\n        ctx === null || ctx === void 0 ? void 0 : ctx.stats.increment('callback_error');\n    })\n        .then(function () { return ctx; }));\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}