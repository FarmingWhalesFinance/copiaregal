{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport useSWR from \"swr\";\nimport VaultReader from \"../abis/VaultReader.json\";\nimport { getContract } from \"src/Addresses\";\nimport { getTokens, getWhitelistedTokens } from \"src/data/Tokens\";\nimport { BASIS_POINTS_DIVISOR, DEFAULT_MAX_USDG_AMOUNT, USD_DECIMALS, USDG_ADDRESS, MAX_PRICE_DEVIATION_BASIS_POINTS, bigNumberify, expandDecimals } from \"src/Helpers\";\nimport { contractFetcher } from \"src/lib/swr/contractFetcher\";\nimport { getServerUrl } from \"src/lib\";\nexport function useInfoTokens(library, chainId, active, tokenBalances, fundingRateInfo, vaultPropsLength) {\n  _s();\n\n  const tokens = getTokens(chainId);\n  const vaultReaderAddress = getContract(chainId, \"VaultReader\");\n  const vaultAddress = getContract(chainId, \"Vault\");\n  const positionRouterAddress = getContract(chainId, \"PositionRouter\");\n  const nativeTokenAddress = getContract(chainId, \"NATIVE_TOKEN\");\n  const whitelistedTokens = getWhitelistedTokens(chainId);\n  const whitelistedTokenAddresses = whitelistedTokens.map(token => token.address);\n  const {\n    data: vaultTokenInfo\n  } = useSWR([`useInfoTokens:${active}`, chainId, vaultReaderAddress, \"getVaultTokenInfoV4\"], {\n    fetcher: contractFetcher(library, VaultReader, [vaultAddress, positionRouterAddress, nativeTokenAddress, expandDecimals(1, 18), whitelistedTokenAddresses])\n  });\n  const indexPricesUrl = getServerUrl(chainId, \"/prices\"); // const indexPricesUrl = `https://pricing.mycelium.xyz/prices?network=${chainId}`;\n\n  const {\n    data: indexPrices\n  } = useSWR([indexPricesUrl], {\n    // @ts-ignore spread args incorrect type\n    fetcher: function () {\n      return fetch(...arguments).then(res => res.json());\n    },\n    refreshInterval: 500,\n    refreshWhenHidden: true\n  });\n  return {\n    infoTokens: getInfoTokens(tokens, tokenBalances, whitelistedTokens, vaultTokenInfo, fundingRateInfo, vaultPropsLength, indexPrices, nativeTokenAddress)\n  };\n}\n\n_s(useInfoTokens, \"pjF8gCHuRNUkOaBKovOWAmvu8sE=\", false, function () {\n  return [useSWR, useSWR];\n});\n\nfunction getInfoTokens(tokens, tokenBalances, whitelistedTokens, vaultTokenInfo, fundingRateInfo, vaultPropsLength, indexPrices, nativeTokenAddress) {\n  if (!vaultPropsLength) {\n    vaultPropsLength = 15;\n  }\n\n  const fundingRatePropsLength = 2;\n  const infoTokens = {};\n\n  for (let i = 0; i < tokens.length; i++) {\n    const token = JSON.parse(JSON.stringify(tokens[i]));\n\n    if (tokenBalances) {\n      token.balance = tokenBalances[i];\n    }\n\n    if (token.address === USDG_ADDRESS) {\n      token.minPrice = expandDecimals(1, USD_DECIMALS);\n      token.maxPrice = expandDecimals(1, USD_DECIMALS);\n    }\n\n    infoTokens[token.address] = token;\n  }\n\n  for (let i = 0; i < whitelistedTokens.length; i++) {\n    const token = JSON.parse(JSON.stringify(whitelistedTokens[i]));\n\n    if (vaultTokenInfo) {\n      token.poolAmount = vaultTokenInfo[i * vaultPropsLength];\n      token.reservedAmount = vaultTokenInfo[i * vaultPropsLength + 1];\n      token.availableAmount = token.poolAmount.sub(token.reservedAmount);\n      token.usdgAmount = vaultTokenInfo[i * vaultPropsLength + 2];\n      token.redemptionAmount = vaultTokenInfo[i * vaultPropsLength + 3];\n      token.weight = vaultTokenInfo[i * vaultPropsLength + 4];\n      token.bufferAmount = vaultTokenInfo[i * vaultPropsLength + 5];\n      token.maxUsdgAmount = vaultTokenInfo[i * vaultPropsLength + 6];\n      token.globalShortSize = vaultTokenInfo[i * vaultPropsLength + 7];\n      token.maxGlobalShortSize = vaultTokenInfo[i * vaultPropsLength + 8];\n      token.maxGlobalLongSize = vaultTokenInfo[i * vaultPropsLength + 9];\n      token.minPrice = vaultTokenInfo[i * vaultPropsLength + 10];\n      token.maxPrice = vaultTokenInfo[i * vaultPropsLength + 11];\n      token.guaranteedUsd = vaultTokenInfo[i * vaultPropsLength + 12];\n      token.maxPrimaryPrice = vaultTokenInfo[i * vaultPropsLength + 13];\n      token.minPrimaryPrice = vaultTokenInfo[i * vaultPropsLength + 14]; // save minPrice and maxPrice as setTokenUsingIndexPrices may override it\n\n      token.contractMinPrice = token.minPrice;\n      token.contractMaxPrice = token.maxPrice;\n      token.maxAvailableShort = bigNumberify(0);\n      token.hasMaxAvailableShort = false;\n\n      if (token.maxGlobalShortSize.gt(0)) {\n        token.hasMaxAvailableShort = true;\n\n        if (token.maxGlobalShortSize.gt(token.globalShortSize)) {\n          token.maxAvailableShort = token.maxGlobalShortSize.sub(token.globalShortSize);\n        }\n      }\n\n      if (token.maxUsdgAmount.eq(0)) {\n        token.maxUsdgAmount = DEFAULT_MAX_USDG_AMOUNT;\n      }\n\n      token.availableUsd = token.isStable ? token.poolAmount.mul(token.minPrice).div(expandDecimals(1, token.decimals)) : token.availableAmount.mul(token.minPrice).div(expandDecimals(1, token.decimals));\n      token.maxAvailableLong = bigNumberify(0);\n      token.hasMaxAvailableLong = false;\n\n      if (token.maxGlobalLongSize.gt(0)) {\n        token.hasMaxAvailableLong = true;\n\n        if (token.maxGlobalLongSize.gt(token.guaranteedUsd)) {\n          const remainingLongSize = token.maxGlobalLongSize.sub(token.guaranteedUsd);\n          token.maxAvailableLong = remainingLongSize.lt(token.availableUsd) ? remainingLongSize : token.availableUsd;\n        }\n      } else {\n        token.maxAvailableLong = token.availableUsd;\n      }\n\n      token.maxLongCapacity = token.maxGlobalLongSize.gt(0) && token.maxGlobalLongSize.lt(token.availableUsd.add(token.guaranteedUsd)) ? token.maxGlobalLongSize : token.availableUsd.add(token.guaranteedUsd);\n      token.managedUsd = token.availableUsd.add(token.guaranteedUsd);\n      token.managedAmount = token.managedUsd.mul(expandDecimals(1, token.decimals)).div(token.minPrice);\n      setTokenUsingIndexPrices(token, indexPrices, nativeTokenAddress);\n    }\n\n    if (fundingRateInfo) {\n      token.fundingRate = fundingRateInfo[i * fundingRatePropsLength];\n      token.cumulativeFundingRate = fundingRateInfo[i * fundingRatePropsLength + 1];\n    }\n\n    if (infoTokens[token.address]) {\n      token.balance = infoTokens[token.address].balance;\n    }\n\n    infoTokens[token.address] = token;\n  }\n\n  return infoTokens;\n}\n\nfunction setTokenUsingIndexPrices(token, indexPrices, nativeTokenAddress) {\n  if (!indexPrices) {\n    return;\n  }\n\n  const tokenAddress = token.isNative ? nativeTokenAddress : token.address;\n  const indexPrice = indexPrices[tokenAddress];\n\n  if (!indexPrice) {\n    return;\n  }\n\n  const indexPriceBn = bigNumberify(indexPrice);\n\n  if (indexPriceBn.eq(0)) {\n    return;\n  }\n\n  const spread = token.maxPrice.sub(token.minPrice);\n  const spreadBps = spread.mul(BASIS_POINTS_DIVISOR).div(token.maxPrice.add(token.minPrice).div(2));\n\n  if (spreadBps.gt(MAX_PRICE_DEVIATION_BASIS_POINTS - 50)) {\n    // only set one of the values as there will be a spread between the index price and the Chainlink price\n    if (indexPriceBn.gt(token.minPrimaryPrice)) {\n      token.maxPrice = indexPriceBn;\n    } else {\n      token.minPrice = indexPriceBn;\n    }\n\n    return;\n  }\n\n  const halfSpreadBps = spreadBps.div(2).toNumber();\n  token.maxPrice = indexPriceBn.mul(BASIS_POINTS_DIVISOR + halfSpreadBps).div(BASIS_POINTS_DIVISOR);\n  token.minPrice = indexPriceBn.mul(BASIS_POINTS_DIVISOR - halfSpreadBps).div(BASIS_POINTS_DIVISOR);\n}","map":{"version":3,"names":["useSWR","VaultReader","getContract","getTokens","getWhitelistedTokens","BASIS_POINTS_DIVISOR","DEFAULT_MAX_USDG_AMOUNT","USD_DECIMALS","USDG_ADDRESS","MAX_PRICE_DEVIATION_BASIS_POINTS","bigNumberify","expandDecimals","contractFetcher","getServerUrl","useInfoTokens","library","chainId","active","tokenBalances","fundingRateInfo","vaultPropsLength","tokens","vaultReaderAddress","vaultAddress","positionRouterAddress","nativeTokenAddress","whitelistedTokens","whitelistedTokenAddresses","map","token","address","data","vaultTokenInfo","fetcher","indexPricesUrl","indexPrices","fetch","then","res","json","refreshInterval","refreshWhenHidden","infoTokens","getInfoTokens","fundingRatePropsLength","i","length","JSON","parse","stringify","balance","minPrice","maxPrice","poolAmount","reservedAmount","availableAmount","sub","usdgAmount","redemptionAmount","weight","bufferAmount","maxUsdgAmount","globalShortSize","maxGlobalShortSize","maxGlobalLongSize","guaranteedUsd","maxPrimaryPrice","minPrimaryPrice","contractMinPrice","contractMaxPrice","maxAvailableShort","hasMaxAvailableShort","gt","eq","availableUsd","isStable","mul","div","decimals","maxAvailableLong","hasMaxAvailableLong","remainingLongSize","lt","maxLongCapacity","add","managedUsd","managedAmount","setTokenUsingIndexPrices","fundingRate","cumulativeFundingRate","tokenAddress","isNative","indexPrice","indexPriceBn","spread","spreadBps","halfSpreadBps","toNumber"],"sources":["C:/Users/rober/Documents/swaps-client/src/hooks/useInfoTokens.ts"],"sourcesContent":["import useSWR from \"swr\";\nimport VaultReader from \"../abis/VaultReader.json\";\nimport { InfoTokens, Token, TokenInfo } from \"../types/tokens\";\nimport { BigNumber } from \"ethers\";\nimport { getContract } from \"src/Addresses\";\nimport { getTokens, getWhitelistedTokens } from \"src/data/Tokens\";\nimport { BASIS_POINTS_DIVISOR, DEFAULT_MAX_USDG_AMOUNT, USD_DECIMALS, USDG_ADDRESS, MAX_PRICE_DEVIATION_BASIS_POINTS, bigNumberify, expandDecimals } from \"src/Helpers\";\nimport { Library } from \"src/types/common\";\nimport { contractFetcher } from \"src/lib/swr/contractFetcher\";\nimport { getServerUrl } from \"src/lib\";\n\nexport function useInfoTokens(\n  library: Library,\n  chainId: number,\n  active: boolean,\n  tokenBalances?: BigNumber[],\n  fundingRateInfo?: BigNumber[],\n  vaultPropsLength?: number\n) {\n  const tokens = getTokens(chainId);\n  const vaultReaderAddress = getContract(chainId, \"VaultReader\");\n  const vaultAddress = getContract(chainId, \"Vault\");\n  const positionRouterAddress = getContract(chainId, \"PositionRouter\");\n  const nativeTokenAddress = getContract(chainId, \"NATIVE_TOKEN\");\n\n  const whitelistedTokens = getWhitelistedTokens(chainId);\n  const whitelistedTokenAddresses = whitelistedTokens.map((token) => token.address);\n\n  const { data: vaultTokenInfo } = useSWR<BigNumber[], any> (\n    [`useInfoTokens:${active}`, chainId, vaultReaderAddress, \"getVaultTokenInfoV4\"],\n    {\n      fetcher: contractFetcher(library, VaultReader, [\n        vaultAddress,\n        positionRouterAddress,\n        nativeTokenAddress,\n        expandDecimals(1, 18),\n        whitelistedTokenAddresses,\n      ]),\n    }\n  );\n\n  const indexPricesUrl = getServerUrl(chainId, \"/prices\");\n  // const indexPricesUrl = `https://pricing.mycelium.xyz/prices?network=${chainId}`;\n\n  const { data: indexPrices } = useSWR([indexPricesUrl], {\n    // @ts-ignore spread args incorrect type\n    fetcher: (...args) => fetch(...args).then((res) => res.json()),\n    refreshInterval: 500,\n    refreshWhenHidden: true,\n  });\n\n  return {\n    infoTokens: getInfoTokens(\n      tokens,\n      tokenBalances,\n      whitelistedTokens,\n      vaultTokenInfo,\n      fundingRateInfo,\n      vaultPropsLength,\n      indexPrices,\n      nativeTokenAddress\n    ),\n  };\n}\n\nfunction getInfoTokens(\n  tokens: Token[],\n  tokenBalances: BigNumber[] | undefined,\n  whitelistedTokens: Token[],\n  vaultTokenInfo: BigNumber[] | undefined,\n  fundingRateInfo: BigNumber[] | undefined,\n  vaultPropsLength: number | undefined,\n  indexPrices: { [address: string]: BigNumber },\n  nativeTokenAddress: string\n): InfoTokens {\n  if (!vaultPropsLength) {\n    vaultPropsLength = 15;\n  }\n  const fundingRatePropsLength = 2;\n  const infoTokens: InfoTokens = {};\n\n  for (let i = 0; i < tokens.length; i++) {\n    const token = JSON.parse(JSON.stringify(tokens[i])) as TokenInfo;\n\n    if (tokenBalances) {\n      token.balance = tokenBalances[i];\n    }\n\n    if (token.address === USDG_ADDRESS) {\n      token.minPrice = expandDecimals(1, USD_DECIMALS);\n      token.maxPrice = expandDecimals(1, USD_DECIMALS);\n    }\n\n    infoTokens[token.address] = token;\n  }\n\n  for (let i = 0; i < whitelistedTokens.length; i++) {\n    const token = JSON.parse(JSON.stringify(whitelistedTokens[i])) as TokenInfo;\n\n    if (vaultTokenInfo) {\n      token.poolAmount = vaultTokenInfo[i * vaultPropsLength];\n      token.reservedAmount = vaultTokenInfo[i * vaultPropsLength + 1];\n      token.availableAmount = token.poolAmount.sub(token.reservedAmount);\n      token.usdgAmount = vaultTokenInfo[i * vaultPropsLength + 2];\n      token.redemptionAmount = vaultTokenInfo[i * vaultPropsLength + 3];\n      token.weight = vaultTokenInfo[i * vaultPropsLength + 4];\n      token.bufferAmount = vaultTokenInfo[i * vaultPropsLength + 5];\n      token.maxUsdgAmount = vaultTokenInfo[i * vaultPropsLength + 6];\n      token.globalShortSize = vaultTokenInfo[i * vaultPropsLength + 7];\n      token.maxGlobalShortSize = vaultTokenInfo[i * vaultPropsLength + 8];\n      token.maxGlobalLongSize = vaultTokenInfo[i * vaultPropsLength + 9];\n      token.minPrice = vaultTokenInfo[i * vaultPropsLength + 10];\n      token.maxPrice = vaultTokenInfo[i * vaultPropsLength + 11];\n      token.guaranteedUsd = vaultTokenInfo[i * vaultPropsLength + 12];\n      token.maxPrimaryPrice = vaultTokenInfo[i * vaultPropsLength + 13];\n      token.minPrimaryPrice = vaultTokenInfo[i * vaultPropsLength + 14];\n\n      // save minPrice and maxPrice as setTokenUsingIndexPrices may override it\n      token.contractMinPrice = token.minPrice;\n      token.contractMaxPrice = token.maxPrice;\n\n      token.maxAvailableShort = bigNumberify(0)!;\n\n      token.hasMaxAvailableShort = false;\n      if (token.maxGlobalShortSize.gt(0)) {\n        token.hasMaxAvailableShort = true;\n        if (token.maxGlobalShortSize.gt(token.globalShortSize)) {\n          token.maxAvailableShort = token.maxGlobalShortSize.sub(token.globalShortSize);\n        }\n      }\n\n      if (token.maxUsdgAmount.eq(0)) {\n        token.maxUsdgAmount = DEFAULT_MAX_USDG_AMOUNT;\n      }\n\n      token.availableUsd = token.isStable\n        ? token.poolAmount.mul(token.minPrice).div(expandDecimals(1, token.decimals))\n        : token.availableAmount.mul(token.minPrice).div(expandDecimals(1, token.decimals));\n\n      token.maxAvailableLong = bigNumberify(0)!;\n      token.hasMaxAvailableLong = false;\n      if (token.maxGlobalLongSize.gt(0)) {\n        token.hasMaxAvailableLong = true;\n\n        if (token.maxGlobalLongSize.gt(token.guaranteedUsd)) {\n          const remainingLongSize = token.maxGlobalLongSize.sub(token.guaranteedUsd);\n          token.maxAvailableLong = remainingLongSize.lt(token.availableUsd) ? remainingLongSize : token.availableUsd;\n        }\n      } else {\n        token.maxAvailableLong = token.availableUsd;\n      }\n\n      token.maxLongCapacity =\n        token.maxGlobalLongSize.gt(0) && token.maxGlobalLongSize.lt(token.availableUsd.add(token.guaranteedUsd))\n          ? token.maxGlobalLongSize\n          : token.availableUsd.add(token.guaranteedUsd);\n\n      token.managedUsd = token.availableUsd.add(token.guaranteedUsd);\n      token.managedAmount = token.managedUsd.mul(expandDecimals(1, token.decimals)).div(token.minPrice);\n\n      setTokenUsingIndexPrices(token, indexPrices, nativeTokenAddress);\n    }\n\n    if (fundingRateInfo) {\n      token.fundingRate = fundingRateInfo[i * fundingRatePropsLength];\n      token.cumulativeFundingRate = fundingRateInfo[i * fundingRatePropsLength + 1];\n    }\n\n    if (infoTokens[token.address]) {\n      token.balance = infoTokens[token.address].balance;\n    }\n\n    infoTokens[token.address] = token;\n  }\n\n  return infoTokens;\n}\n\nfunction setTokenUsingIndexPrices(\n  token: TokenInfo,\n  indexPrices: { [address: string]: BigNumber },\n  nativeTokenAddress: string\n) {\n  if (!indexPrices) {\n    return;\n  }\n\n  const tokenAddress = token.isNative ? nativeTokenAddress : token.address;\n\n  const indexPrice = indexPrices[tokenAddress];\n\n  if (!indexPrice) {\n    return;\n  }\n\n  const indexPriceBn = bigNumberify(indexPrice)!;\n\n  if (indexPriceBn.eq(0)) {\n    return;\n  }\n\n  const spread = token.maxPrice!.sub(token.minPrice!);\n  const spreadBps = spread.mul(BASIS_POINTS_DIVISOR).div(token.maxPrice!.add(token.minPrice!).div(2));\n\n  if (spreadBps.gt(MAX_PRICE_DEVIATION_BASIS_POINTS - 50)) {\n    // only set one of the values as there will be a spread between the index price and the Chainlink price\n    if (indexPriceBn.gt(token.minPrimaryPrice!)) {\n      token.maxPrice = indexPriceBn;\n    } else {\n      token.minPrice = indexPriceBn;\n    }\n    return;\n  }\n\n  const halfSpreadBps = spreadBps.div(2).toNumber();\n  token.maxPrice = indexPriceBn.mul(BASIS_POINTS_DIVISOR + halfSpreadBps).div(BASIS_POINTS_DIVISOR);\n  token.minPrice = indexPriceBn.mul(BASIS_POINTS_DIVISOR - halfSpreadBps).div(BASIS_POINTS_DIVISOR);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}