{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { isOffline } from '../../core/connection';\nimport { Context } from '../../core/context';\nimport { attempt } from '../../core/queue/delivery';\nimport { pWhile } from '../../lib/p-while';\n\nfunction flushQueue(xt, queue) {\n  return __awaiter(this, void 0, void 0, function () {\n    var failedQueue;\n\n    var _this = this;\n\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          failedQueue = [];\n\n          if (isOffline()) {\n            return [2\n            /*return*/\n            , queue];\n          }\n\n          return [4\n          /*yield*/\n          , pWhile(function () {\n            return queue.length > 0 && !isOffline();\n          }, function () {\n            return __awaiter(_this, void 0, void 0, function () {\n              var ctx, result, success;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    ctx = queue.pop();\n\n                    if (!ctx) {\n                      return [2\n                      /*return*/\n                      ];\n                    }\n\n                    return [4\n                    /*yield*/\n                    , attempt(ctx, xt)];\n\n                  case 1:\n                    result = _a.sent();\n                    success = result instanceof Context;\n\n                    if (!success) {\n                      failedQueue.push(ctx);\n                    }\n\n                    return [2\n                    /*return*/\n                    ];\n                }\n              });\n            });\n          }) // re-add failed tasks\n          ];\n\n        case 1:\n          _a.sent(); // re-add failed tasks\n\n\n          failedQueue.map(function (failed) {\n            return queue.pushWithBackoff(failed);\n          });\n          return [2\n          /*return*/\n          , queue];\n      }\n    });\n  });\n}\n\nexport function scheduleFlush(flushing, buffer, xt, scheduleFlush) {\n  var _this = this;\n\n  if (flushing) {\n    return;\n  } // eslint-disable-next-line @typescript-eslint/no-misused-promises\n\n\n  setTimeout(function () {\n    return __awaiter(_this, void 0, void 0, function () {\n      var isFlushing, newBuffer;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            isFlushing = true;\n            return [4\n            /*yield*/\n            , flushQueue(xt, buffer)];\n\n          case 1:\n            newBuffer = _a.sent();\n            isFlushing = false;\n\n            if (buffer.todo > 0) {\n              scheduleFlush(isFlushing, newBuffer, xt, scheduleFlush);\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }, Math.random() * 5000);\n}","map":{"version":3,"sources":["../../../../src/plugins/segmentio/schedule-flush.ts"],"names":[],"mappings":";AAAA,SAAS,SAAT,QAA0B,uBAA1B;AACA,SAAS,OAAT,QAAwB,oBAAxB;AAEA,SAAS,OAAT,QAAwB,2BAAxB;AACA,SAAS,MAAT,QAAuB,mBAAvB;;AAGA,SAAe,UAAf,CACE,EADF,EAEE,KAFF,EAE+B;;;;;;;;;UAEvB,WAAW,GAAc,EAAzB;;UACN,IAAI,SAAS,EAAb,EAAiB;YACf,OAAA,CAAA;YAAA;YAAA,EAAO,KAAP,CAAA;UACD;;UAED,OAAA,CAAA;UAAA;UAAA,EAAM,MAAM,CACV,YAAA;YAAM,OAAA,KAAK,CAAC,MAAN,GAAe,CAAf,IAAoB,CAAC,SAArB,EAAA;UAAgC,CAD5B,EAEV,YAAA;YAAA,OAAA,SAAA,CAAA,KAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,YAAA;;;;;oBACQ,GAAG,GAAG,KAAK,CAAC,GAAN,EAAN;;oBACN,IAAI,CAAC,GAAL,EAAU;sBACR,OAAA,CAAA;sBAAA;sBAAA,CAAA;oBACD;;oBAEc,OAAA,CAAA;oBAAA;oBAAA,EAAM,OAAO,CAAC,GAAD,EAAM,EAAN,CAAb,CAAA;;;oBAAT,MAAM,GAAG,EAAA,CAAA,IAAA,EAAT;oBACA,OAAO,GAAG,MAAM,YAAY,OAA5B;;oBACN,IAAI,CAAC,OAAL,EAAc;sBACZ,WAAW,CAAC,IAAZ,CAAiB,GAAjB;oBACD;;;;;;;aAVH,CAAA;UAWC,CAbS,CAAZ,CAeA;UAfA,CAAA;;;UAAA,EAAA,CAAA,IAAA,G,CAeA;;;UACA,WAAW,CAAC,GAAZ,CAAgB,UAAC,MAAD,EAAO;YAAK,OAAA,KAAK,CAAC,eAAN,CAAA,MAAA,CAAA;UAA6B,CAAzD;UACA,OAAA,CAAA;UAAA;UAAA,EAAO,KAAP,CAAA;;;;AACD;;AAED,OAAM,SAAU,aAAV,CACJ,QADI,EAEJ,MAFI,EAGJ,EAHI,EAIJ,aAJI,EAImB;EAJzB,IAAA,KAAA,GAAA,IAAA;;EAME,IAAI,QAAJ,EAAc;IACZ;EACD,CAJsB,CAMvB;;;EACA,UAAU,CAAC,YAAA;IAAA,OAAA,SAAA,CAAA,KAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,YAAA;;;;;YACL,UAAU,GAAG,IAAb;YAEc,OAAA,CAAA;YAAA;YAAA,EAAM,UAAU,CAAC,EAAD,EAAK,MAAL,CAAhB,CAAA;;;YAAZ,SAAS,GAAG,EAAA,CAAA,IAAA,EAAZ;YACN,UAAU,GAAG,KAAb;;YAEA,IAAI,MAAM,CAAC,IAAP,GAAc,CAAlB,EAAqB;cACnB,aAAa,CAAC,UAAD,EAAa,SAAb,EAAwB,EAAxB,EAA4B,aAA5B,CAAb;YACD;;;;;;;KARQ,CAAA;EASV,CATS,EASP,IAAI,CAAC,MAAL,KAAgB,IATT,CAAV;AAUD","sourceRoot":"","sourcesContent":["import { __awaiter, __generator } from \"tslib\";\nimport { isOffline } from '../../core/connection';\nimport { Context } from '../../core/context';\nimport { attempt } from '../../core/queue/delivery';\nimport { pWhile } from '../../lib/p-while';\nfunction flushQueue(xt, queue) {\n    return __awaiter(this, void 0, void 0, function () {\n        var failedQueue;\n        var _this = this;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    failedQueue = [];\n                    if (isOffline()) {\n                        return [2 /*return*/, queue];\n                    }\n                    return [4 /*yield*/, pWhile(function () { return queue.length > 0 && !isOffline(); }, function () { return __awaiter(_this, void 0, void 0, function () {\n                            var ctx, result, success;\n                            return __generator(this, function (_a) {\n                                switch (_a.label) {\n                                    case 0:\n                                        ctx = queue.pop();\n                                        if (!ctx) {\n                                            return [2 /*return*/];\n                                        }\n                                        return [4 /*yield*/, attempt(ctx, xt)];\n                                    case 1:\n                                        result = _a.sent();\n                                        success = result instanceof Context;\n                                        if (!success) {\n                                            failedQueue.push(ctx);\n                                        }\n                                        return [2 /*return*/];\n                                }\n                            });\n                        }); })\n                        // re-add failed tasks\n                    ];\n                case 1:\n                    _a.sent();\n                    // re-add failed tasks\n                    failedQueue.map(function (failed) { return queue.pushWithBackoff(failed); });\n                    return [2 /*return*/, queue];\n            }\n        });\n    });\n}\nexport function scheduleFlush(flushing, buffer, xt, scheduleFlush) {\n    var _this = this;\n    if (flushing) {\n        return;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    setTimeout(function () { return __awaiter(_this, void 0, void 0, function () {\n        var isFlushing, newBuffer;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    isFlushing = true;\n                    return [4 /*yield*/, flushQueue(xt, buffer)];\n                case 1:\n                    newBuffer = _a.sent();\n                    isFlushing = false;\n                    if (buffer.todo > 0) {\n                        scheduleFlush(isFlushing, newBuffer, xt, scheduleFlush);\n                    }\n                    return [2 /*return*/];\n            }\n        });\n    }); }, Math.random() * 5000);\n}\n//# sourceMappingURL=schedule-flush.js.map"]},"metadata":{},"sourceType":"module"}