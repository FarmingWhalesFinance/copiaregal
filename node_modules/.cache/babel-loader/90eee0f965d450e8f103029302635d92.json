{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar md5_1 = __importDefault(require(\"tiny-hashes/md5\"));\n\nvar dlv_1 = __importDefault(require(\"dlv\"));\n\nvar math_base_special_ldexp_1 = __importDefault(require(\"@stdlib/math-base-special-ldexp\"));\n\nvar dset_1 = require(\"dset\");\n\nvar unset_1 = require(\"./unset\");\n\nfunction transform(payload, transformers) {\n  var transformedPayload = payload;\n\n  for (var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++) {\n    var transformer = transformers_1[_i];\n\n    switch (transformer.type) {\n      case 'drop':\n        return null;\n\n      case 'drop_properties':\n        dropProperties(transformedPayload, transformer.config);\n        break;\n\n      case 'allow_properties':\n        allowProperties(transformedPayload, transformer.config);\n        break;\n\n      case 'sample_event':\n        if (sampleEvent(transformedPayload, transformer.config)) {\n          break;\n        }\n\n        return null;\n\n      case 'map_properties':\n        mapProperties(transformedPayload, transformer.config);\n        break;\n\n      case 'hash_properties':\n        // Not yet supported, but don't throw an error. Just ignore.\n        break;\n\n      default:\n        throw new Error(\"Transformer of type \\\"\".concat(transformer.type, \"\\\" is unsupported.\"));\n    }\n  }\n\n  return transformedPayload;\n}\n\nexports.default = transform; // dropProperties removes all specified props from the object.\n\nfunction dropProperties(payload, config) {\n  for (var key in config.drop) {\n    if (!config.drop.hasOwnProperty(key)) {\n      continue;\n    } // If key is empty, it refers to the top-level object.\n\n\n    var field = key === '' ? payload : (0, dlv_1.default)(payload, key); // Can only drop props off of arrays and objects.\n\n    if (typeof field !== 'object' || field === null) {\n      continue;\n    }\n\n    for (var _i = 0, _a = config.drop[key]; _i < _a.length; _i++) {\n      var target = _a[_i];\n      delete field[target];\n    }\n  }\n} // allowProperties ONLY allows the specific targets within the keys. (e.g. \"a.foo\": [\"bar\", \"baz\"]\n// on {a: {foo: {bar: 1, baz: 2}, other: 3}} will not have any drops, as it only looks inside a.foo\n\n\nfunction allowProperties(payload, config) {\n  for (var key in config.allow) {\n    if (!config.allow.hasOwnProperty(key)) {\n      continue;\n    } // If key is empty, it refers to the top-level object.\n\n\n    var field = key === '' ? payload : (0, dlv_1.default)(payload, key); // Can only drop props off of arrays and objects.\n\n    if (typeof field !== 'object' || field === null) {\n      continue;\n    } // Execution order fortunately doesn't really matter (e.g. if someone filtered off of foo.bar, then foo.bar.baz)\n    // except for micro-optimization.\n\n\n    for (var k in field) {\n      if (!field.hasOwnProperty(k)) {\n        continue;\n      }\n\n      if (config.allow[key].indexOf(k) === -1) {\n        delete field[k];\n      }\n    }\n  }\n}\n\nfunction mapProperties(payload, config) {\n  // Some configs might try to modify or read from a field multiple times. We will only ever read\n  // values as they were before any modifications began. Thus, if you try to override e.g.\n  // {a: {b: 1}} with set(a, 'b', 2) (which results in {a: {b: 2}}) and then try to copy a.b into\n  // a.c, you will get {a: {b: 2, c:1}} and NOT {a: {b:2, c:2}}. This prevents map evaluation\n  // order from mattering, and === what server-side does.\n  // See: https://github.com/segmentio/tsub/blob/661695a63b60b90471796e667458f076af788c19/transformers/map_properties.go#L179-L200\n  var initialPayload = JSON.parse(JSON.stringify(payload));\n\n  for (var key in config.map) {\n    if (!config.map.hasOwnProperty(key)) {\n      continue;\n    }\n\n    var actionMap = config.map[key]; // Can't manipulate non-objects. Check that the parent is one. Strip the last .field\n    // from the string.\n\n    var splitKey = key.split('.');\n    var parent_1 = void 0;\n\n    if (splitKey.length > 1) {\n      splitKey.pop();\n      parent_1 = (0, dlv_1.default)(initialPayload, splitKey.join('.'));\n    } else {\n      parent_1 = payload;\n    }\n\n    if (typeof parent_1 !== 'object') {\n      continue;\n    } // These actions are exclusive to each other.\n\n\n    if (actionMap.copy) {\n      var valueToCopy = (0, dlv_1.default)(initialPayload, actionMap.copy);\n\n      if (valueToCopy !== undefined) {\n        (0, dset_1.dset)(payload, key, valueToCopy);\n      }\n    } else if (actionMap.move) {\n      var valueToMove = (0, dlv_1.default)(initialPayload, actionMap.move);\n\n      if (valueToMove !== undefined) {\n        (0, dset_1.dset)(payload, key, valueToMove);\n      }\n\n      (0, unset_1.unset)(payload, actionMap.move);\n    } // Have to check only if property exists, as null, undefined, and other vals could be explicitly set.\n    else if (actionMap.hasOwnProperty('set')) {\n      (0, dset_1.dset)(payload, key, actionMap.set);\n    } // to_string is not exclusive and can be paired with other actions. Final action.\n\n\n    if (actionMap.to_string) {\n      var valueToString = (0, dlv_1.default)(payload, key); // Do not string arrays and objects. Do not double-encode strings.\n\n      if (typeof valueToString === 'string' || typeof valueToString === 'object' && valueToString !== null) {\n        continue;\n      } // TODO: Check stringifier in Golang for parity.\n\n\n      if (valueToString !== undefined) {\n        (0, dset_1.dset)(payload, key, JSON.stringify(valueToString));\n      } else {\n        // TODO: Check this behavior.\n        (0, dset_1.dset)(payload, key, 'undefined');\n      }\n    }\n  }\n}\n\nfunction sampleEvent(payload, config) {\n  if (config.sample.percent <= 0) {\n    return false;\n  } else if (config.sample.percent >= 1) {\n    return true;\n  } // If we're not filtering deterministically, just use raw percentage.\n\n\n  if (!config.sample.path) {\n    return samplePercent(config.sample.percent);\n  } // Otherwise, use a deterministic hash.\n\n\n  return sampleConsistentPercent(payload, config);\n}\n\nfunction samplePercent(percent) {\n  // Math.random returns [0, 1) => 0.0<>0.9999...\n  return Math.random() <= percent;\n} // sampleConsistentPercent converts an input string of bytes into a consistent uniform\n// continuous distribution of [0.0, 1.0]. This is based on\n// http://mumble.net/~campbell/tmp/random_real.c, but using the digest\n// result of the input value as the random information.\n// IMPORTANT - This function needs to === the Golang implementation to ensure that the two return the same vals!\n// See: https://github.com/segmentio/sampler/blob/65cb04132305a04fcd4bcaef67d57fbe40c30241/sampler.go#L13-L38\n// Since AJS supports IE9+ (typed arrays were introduced in IE10) we're doing some manual array math.\n// This could be done directly with strings, but arrays are easier to reason about/have better function support.\n\n\nfunction sampleConsistentPercent(payload, config) {\n  var field = (0, dlv_1.default)(payload, config.sample.path); // Operate off of JSON bytes. TODO: Validate all type behavior, esp. strings.\n\n  var digest = (0, md5_1.default)(JSON.stringify(field));\n  var exponent = -64; // Manually maintain 64-bit int as an array.\n\n  var significand = []; // Left-shift and OR for first 8 bytes of digest. (8 bytes * 8 = 64 bits)\n\n  consumeDigest(digest.slice(0, 8), significand);\n  var leadingZeros = 0;\n\n  for (var i = 0; i < 64; i++) {\n    if (significand[i] === 1) {\n      break;\n    }\n\n    leadingZeros++;\n  }\n\n  if (leadingZeros !== 0) {\n    // Use the last 8 bytes of the digest, same as before.\n    var val = [];\n    consumeDigest(digest.slice(9, 16), val);\n    exponent -= leadingZeros; // Left-shift away leading zeros in significand.\n\n    significand.splice(0, leadingZeros); // Right-shift val by 64 minus leading zeros and push into significand.\n\n    val.splice(64 - leadingZeros);\n    significand = significand.concat(val);\n  } // Flip 64th bit\n\n\n  significand[63] = significand[63] === 0 ? 1 : 0; // Convert our manual binary into a JS num (binary arr => binary string => psuedo-int) and run the ldexp!\n\n  return (0, math_base_special_ldexp_1.default)(parseInt(significand.join(''), 2), exponent) < config.sample.percent;\n} // Array byte filler helper\n\n\nfunction consumeDigest(digest, arr) {\n  for (var i = 0; i < 8; i++) {\n    var remainder = digest[i];\n\n    for (var binary = 128; binary >= 1; binary /= 2) {\n      if (remainder - binary >= 0) {\n        remainder -= binary;\n        arr.push(1);\n      } else {\n        arr.push(0);\n      }\n    }\n  }\n}","map":{"version":3,"sources":["../src/transformers.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar md5_1 = __importDefault(require(\"tiny-hashes/md5\"));\nvar dlv_1 = __importDefault(require(\"dlv\"));\nvar math_base_special_ldexp_1 = __importDefault(require(\"@stdlib/math-base-special-ldexp\"));\nvar dset_1 = require(\"dset\");\nvar unset_1 = require(\"./unset\");\nfunction transform(payload, transformers) {\n    var transformedPayload = payload;\n    for (var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++) {\n        var transformer = transformers_1[_i];\n        switch (transformer.type) {\n            case 'drop':\n                return null;\n            case 'drop_properties':\n                dropProperties(transformedPayload, transformer.config);\n                break;\n            case 'allow_properties':\n                allowProperties(transformedPayload, transformer.config);\n                break;\n            case 'sample_event':\n                if (sampleEvent(transformedPayload, transformer.config)) {\n                    break;\n                }\n                return null;\n            case 'map_properties':\n                mapProperties(transformedPayload, transformer.config);\n                break;\n            case 'hash_properties':\n                // Not yet supported, but don't throw an error. Just ignore.\n                break;\n            default:\n                throw new Error(\"Transformer of type \\\"\".concat(transformer.type, \"\\\" is unsupported.\"));\n        }\n    }\n    return transformedPayload;\n}\nexports.default = transform;\n// dropProperties removes all specified props from the object.\nfunction dropProperties(payload, config) {\n    for (var key in config.drop) {\n        if (!config.drop.hasOwnProperty(key)) {\n            continue;\n        }\n        // If key is empty, it refers to the top-level object.\n        var field = key === '' ? payload : (0, dlv_1.default)(payload, key);\n        // Can only drop props off of arrays and objects.\n        if (typeof field !== 'object' || field === null) {\n            continue;\n        }\n        for (var _i = 0, _a = config.drop[key]; _i < _a.length; _i++) {\n            var target = _a[_i];\n            delete field[target];\n        }\n    }\n}\n// allowProperties ONLY allows the specific targets within the keys. (e.g. \"a.foo\": [\"bar\", \"baz\"]\n// on {a: {foo: {bar: 1, baz: 2}, other: 3}} will not have any drops, as it only looks inside a.foo\nfunction allowProperties(payload, config) {\n    for (var key in config.allow) {\n        if (!config.allow.hasOwnProperty(key)) {\n            continue;\n        }\n        // If key is empty, it refers to the top-level object.\n        var field = key === '' ? payload : (0, dlv_1.default)(payload, key);\n        // Can only drop props off of arrays and objects.\n        if (typeof field !== 'object' || field === null) {\n            continue;\n        }\n        // Execution order fortunately doesn't really matter (e.g. if someone filtered off of foo.bar, then foo.bar.baz)\n        // except for micro-optimization.\n        for (var k in field) {\n            if (!field.hasOwnProperty(k)) {\n                continue;\n            }\n            if (config.allow[key].indexOf(k) === -1) {\n                delete field[k];\n            }\n        }\n    }\n}\nfunction mapProperties(payload, config) {\n    // Some configs might try to modify or read from a field multiple times. We will only ever read\n    // values as they were before any modifications began. Thus, if you try to override e.g.\n    // {a: {b: 1}} with set(a, 'b', 2) (which results in {a: {b: 2}}) and then try to copy a.b into\n    // a.c, you will get {a: {b: 2, c:1}} and NOT {a: {b:2, c:2}}. This prevents map evaluation\n    // order from mattering, and === what server-side does.\n    // See: https://github.com/segmentio/tsub/blob/661695a63b60b90471796e667458f076af788c19/transformers/map_properties.go#L179-L200\n    var initialPayload = JSON.parse(JSON.stringify(payload));\n    for (var key in config.map) {\n        if (!config.map.hasOwnProperty(key)) {\n            continue;\n        }\n        var actionMap = config.map[key];\n        // Can't manipulate non-objects. Check that the parent is one. Strip the last .field\n        // from the string.\n        var splitKey = key.split('.');\n        var parent_1 = void 0;\n        if (splitKey.length > 1) {\n            splitKey.pop();\n            parent_1 = (0, dlv_1.default)(initialPayload, splitKey.join('.'));\n        }\n        else {\n            parent_1 = payload;\n        }\n        if (typeof parent_1 !== 'object') {\n            continue;\n        }\n        // These actions are exclusive to each other.\n        if (actionMap.copy) {\n            var valueToCopy = (0, dlv_1.default)(initialPayload, actionMap.copy);\n            if (valueToCopy !== undefined) {\n                (0, dset_1.dset)(payload, key, valueToCopy);\n            }\n        }\n        else if (actionMap.move) {\n            var valueToMove = (0, dlv_1.default)(initialPayload, actionMap.move);\n            if (valueToMove !== undefined) {\n                (0, dset_1.dset)(payload, key, valueToMove);\n            }\n            (0, unset_1.unset)(payload, actionMap.move);\n        }\n        // Have to check only if property exists, as null, undefined, and other vals could be explicitly set.\n        else if (actionMap.hasOwnProperty('set')) {\n            (0, dset_1.dset)(payload, key, actionMap.set);\n        }\n        // to_string is not exclusive and can be paired with other actions. Final action.\n        if (actionMap.to_string) {\n            var valueToString = (0, dlv_1.default)(payload, key);\n            // Do not string arrays and objects. Do not double-encode strings.\n            if (typeof valueToString === 'string' ||\n                (typeof valueToString === 'object' && valueToString !== null)) {\n                continue;\n            }\n            // TODO: Check stringifier in Golang for parity.\n            if (valueToString !== undefined) {\n                (0, dset_1.dset)(payload, key, JSON.stringify(valueToString));\n            }\n            else {\n                // TODO: Check this behavior.\n                (0, dset_1.dset)(payload, key, 'undefined');\n            }\n        }\n    }\n}\nfunction sampleEvent(payload, config) {\n    if (config.sample.percent <= 0) {\n        return false;\n    }\n    else if (config.sample.percent >= 1) {\n        return true;\n    }\n    // If we're not filtering deterministically, just use raw percentage.\n    if (!config.sample.path) {\n        return samplePercent(config.sample.percent);\n    }\n    // Otherwise, use a deterministic hash.\n    return sampleConsistentPercent(payload, config);\n}\nfunction samplePercent(percent) {\n    // Math.random returns [0, 1) => 0.0<>0.9999...\n    return Math.random() <= percent;\n}\n// sampleConsistentPercent converts an input string of bytes into a consistent uniform\n// continuous distribution of [0.0, 1.0]. This is based on\n// http://mumble.net/~campbell/tmp/random_real.c, but using the digest\n// result of the input value as the random information.\n// IMPORTANT - This function needs to === the Golang implementation to ensure that the two return the same vals!\n// See: https://github.com/segmentio/sampler/blob/65cb04132305a04fcd4bcaef67d57fbe40c30241/sampler.go#L13-L38\n// Since AJS supports IE9+ (typed arrays were introduced in IE10) we're doing some manual array math.\n// This could be done directly with strings, but arrays are easier to reason about/have better function support.\nfunction sampleConsistentPercent(payload, config) {\n    var field = (0, dlv_1.default)(payload, config.sample.path);\n    // Operate off of JSON bytes. TODO: Validate all type behavior, esp. strings.\n    var digest = (0, md5_1.default)(JSON.stringify(field));\n    var exponent = -64;\n    // Manually maintain 64-bit int as an array.\n    var significand = [];\n    // Left-shift and OR for first 8 bytes of digest. (8 bytes * 8 = 64 bits)\n    consumeDigest(digest.slice(0, 8), significand);\n    var leadingZeros = 0;\n    for (var i = 0; i < 64; i++) {\n        if (significand[i] === 1) {\n            break;\n        }\n        leadingZeros++;\n    }\n    if (leadingZeros !== 0) {\n        // Use the last 8 bytes of the digest, same as before.\n        var val = [];\n        consumeDigest(digest.slice(9, 16), val);\n        exponent -= leadingZeros;\n        // Left-shift away leading zeros in significand.\n        significand.splice(0, leadingZeros);\n        // Right-shift val by 64 minus leading zeros and push into significand.\n        val.splice(64 - leadingZeros);\n        significand = significand.concat(val);\n    }\n    // Flip 64th bit\n    significand[63] = significand[63] === 0 ? 1 : 0;\n    // Convert our manual binary into a JS num (binary arr => binary string => psuedo-int) and run the ldexp!\n    return (0, math_base_special_ldexp_1.default)(parseInt(significand.join(''), 2), exponent) < config.sample.percent;\n}\n// Array byte filler helper\nfunction consumeDigest(digest, arr) {\n    for (var i = 0; i < 8; i++) {\n        var remainder = digest[i];\n        for (var binary = 128; binary >= 1; binary /= 2) {\n            if (remainder - binary >= 0) {\n                remainder -= binary;\n                arr.push(1);\n            }\n            else {\n                arr.push(0);\n            }\n        }\n    }\n}\n//# sourceMappingURL=transformers.js.map"]},"metadata":{},"sourceType":"script"}