{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { isThenable } from '../../lib/is-thenable';\nimport { version } from '../../generated/version';\n\nvar flushSyncAnalyticsCalls = function (name, analytics, buffer) {\n  buffer.getCalls(name).forEach(function (c) {\n    // While the underlying methods are synchronous, the callAnalyticsMethod returns a promise,\n    // which normalizes success and error states between async and non-async methods, with no perf penalty.\n    callAnalyticsMethod(analytics, c).catch(console.error);\n  });\n};\n\nexport var flushAddSourceMiddleware = function (analytics, buffer) {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var _i, _a, c;\n\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          _i = 0, _a = buffer.getCalls('addSourceMiddleware');\n          _b.label = 1;\n\n        case 1:\n          if (!(_i < _a.length)) return [3\n          /*break*/\n          , 4];\n          c = _a[_i];\n          return [4\n          /*yield*/\n          , callAnalyticsMethod(analytics, c).catch(console.error)];\n\n        case 2:\n          _b.sent();\n\n          _b.label = 3;\n\n        case 3:\n          _i++;\n          return [3\n          /*break*/\n          , 1];\n\n        case 4:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n};\nexport var flushOn = flushSyncAnalyticsCalls.bind(this, 'on');\nexport var flushSetAnonymousID = flushSyncAnalyticsCalls.bind(this, 'setAnonymousId');\nexport var flushAnalyticsCallsInNewTask = function (analytics, buffer) {\n  buffer.toArray().forEach(function (m) {\n    setTimeout(function () {\n      callAnalyticsMethod(analytics, m).catch(console.error);\n    }, 0);\n  });\n};\n/**\n *  Represents any and all the buffered method calls that occurred before initialization.\n */\n\nvar PreInitMethodCallBuffer =\n/** @class */\nfunction () {\n  function PreInitMethodCallBuffer() {\n    this._value = {};\n  }\n\n  PreInitMethodCallBuffer.prototype.toArray = function () {\n    var _a;\n\n    return (_a = []).concat.apply(_a, Object.values(this._value));\n  };\n\n  PreInitMethodCallBuffer.prototype.getCalls = function (methodName) {\n    var _a;\n\n    return (_a = this._value[methodName]) !== null && _a !== void 0 ? _a : [];\n  };\n\n  PreInitMethodCallBuffer.prototype.push = function () {\n    var _this = this;\n\n    var calls = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      calls[_i] = arguments[_i];\n    }\n\n    calls.forEach(function (call) {\n      if (_this._value[call.method]) {\n        _this._value[call.method].push(call);\n      } else {\n        _this._value[call.method] = [call];\n      }\n    });\n    return this;\n  };\n\n  PreInitMethodCallBuffer.prototype.clear = function () {\n    this._value = {};\n    return this;\n  };\n\n  return PreInitMethodCallBuffer;\n}();\n\nexport { PreInitMethodCallBuffer };\n/**\n *  Call method and mark as \"called\"\n *  This function should never throw an error\n */\n\nexport function callAnalyticsMethod(analytics, call) {\n  return __awaiter(this, void 0, void 0, function () {\n    var result, err_1;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          _a.trys.push([0, 3,, 4]);\n\n          if (call.called) {\n            return [2\n            /*return*/\n            , undefined];\n          }\n\n          call.called = true;\n          result = analytics[call.method].apply(analytics, call.args);\n          if (!isThenable(result)) return [3\n          /*break*/\n          , 2]; // do not defer for non-async methods\n\n          return [4\n          /*yield*/\n          , result];\n\n        case 1:\n          // do not defer for non-async methods\n          _a.sent();\n\n          _a.label = 2;\n\n        case 2:\n          call.resolve(result);\n          return [3\n          /*break*/\n          , 4];\n\n        case 3:\n          err_1 = _a.sent();\n          call.reject(err_1);\n          return [3\n          /*break*/\n          , 4];\n\n        case 4:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n\nvar AnalyticsBuffered =\n/** @class */\nfunction () {\n  function AnalyticsBuffered(loader) {\n    var _this = this;\n\n    this._preInitBuffer = new PreInitMethodCallBuffer();\n    this.trackSubmit = this._createMethod('trackSubmit');\n    this.trackClick = this._createMethod('trackClick');\n    this.trackLink = this._createMethod('trackLink');\n    this.pageView = this._createMethod('pageview');\n    this.identify = this._createMethod('identify');\n    this.reset = this._createMethod('reset');\n    this.group = this._createMethod('group');\n    this.track = this._createMethod('track');\n    this.ready = this._createMethod('ready');\n    this.alias = this._createMethod('alias');\n    this.debug = this._createChainableMethod('debug');\n    this.page = this._createMethod('page');\n    this.once = this._createChainableMethod('once');\n    this.off = this._createChainableMethod('off');\n    this.on = this._createChainableMethod('on');\n    this.addSourceMiddleware = this._createMethod('addSourceMiddleware');\n    this.setAnonymousId = this._createMethod('setAnonymousId');\n    this.addDestinationMiddleware = this._createMethod('addDestinationMiddleware');\n    this.screen = this._createMethod('screen');\n    this.register = this._createMethod('register');\n    this.deregister = this._createMethod('deregister');\n    this.user = this._createMethod('user');\n    this.VERSION = version;\n    this._promise = loader(this._preInitBuffer);\n\n    this._promise.then(function (_a) {\n      var ajs = _a[0],\n          ctx = _a[1];\n      _this.instance = ajs;\n      _this.ctx = ctx;\n    }).catch(function () {// intentionally do nothing...\n      // this result of this promise will be caught by the 'catch' block on this class.\n    });\n  }\n\n  AnalyticsBuffered.prototype.then = function () {\n    var _a;\n\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    return (_a = this._promise).then.apply(_a, args);\n  };\n\n  AnalyticsBuffered.prototype.catch = function () {\n    var _a;\n\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    return (_a = this._promise).catch.apply(_a, args);\n  };\n\n  AnalyticsBuffered.prototype.finally = function () {\n    var _a;\n\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    return (_a = this._promise).finally.apply(_a, args);\n  };\n\n  AnalyticsBuffered.prototype._createMethod = function (methodName) {\n    var _this = this;\n\n    return function () {\n      var _a;\n\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      if (_this.instance) {\n        var result = (_a = _this.instance)[methodName].apply(_a, args);\n\n        return Promise.resolve(result);\n      }\n\n      return new Promise(function (resolve, reject) {\n        _this._preInitBuffer.push({\n          method: methodName,\n          args: args,\n          resolve: resolve,\n          reject: reject,\n          called: false\n        });\n      });\n    };\n  };\n  /**\n   *  These are for methods that where determining when the method gets \"flushed\" is not important.\n   *  These methods will resolve when analytics is fully initialized, and return type (other than Analytics)will not be available.\n   */\n\n\n  AnalyticsBuffered.prototype._createChainableMethod = function (methodName) {\n    var _this = this;\n\n    return function () {\n      var _a;\n\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      if (_this.instance) {\n        void (_a = _this.instance)[methodName].apply(_a, args);\n        return _this;\n      } else {\n        _this._preInitBuffer.push({\n          method: methodName,\n          args: args,\n          resolve: function () {},\n          reject: console.error,\n          called: false\n        });\n      }\n\n      return _this;\n    };\n  };\n\n  return AnalyticsBuffered;\n}();\n\nexport { AnalyticsBuffered };","map":{"version":3,"sources":["../../../../src/core/buffer/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __awaiter, __generator } from \"tslib\";\nimport { isThenable } from '../../lib/is-thenable';\nimport { version } from '../../generated/version';\nvar flushSyncAnalyticsCalls = function (name, analytics, buffer) {\n    buffer.getCalls(name).forEach(function (c) {\n        // While the underlying methods are synchronous, the callAnalyticsMethod returns a promise,\n        // which normalizes success and error states between async and non-async methods, with no perf penalty.\n        callAnalyticsMethod(analytics, c).catch(console.error);\n    });\n};\nexport var flushAddSourceMiddleware = function (analytics, buffer) { return __awaiter(void 0, void 0, void 0, function () {\n    var _i, _a, c;\n    return __generator(this, function (_b) {\n        switch (_b.label) {\n            case 0:\n                _i = 0, _a = buffer.getCalls('addSourceMiddleware');\n                _b.label = 1;\n            case 1:\n                if (!(_i < _a.length)) return [3 /*break*/, 4];\n                c = _a[_i];\n                return [4 /*yield*/, callAnalyticsMethod(analytics, c).catch(console.error)];\n            case 2:\n                _b.sent();\n                _b.label = 3;\n            case 3:\n                _i++;\n                return [3 /*break*/, 1];\n            case 4: return [2 /*return*/];\n        }\n    });\n}); };\nexport var flushOn = flushSyncAnalyticsCalls.bind(this, 'on');\nexport var flushSetAnonymousID = flushSyncAnalyticsCalls.bind(this, 'setAnonymousId');\nexport var flushAnalyticsCallsInNewTask = function (analytics, buffer) {\n    buffer.toArray().forEach(function (m) {\n        setTimeout(function () {\n            callAnalyticsMethod(analytics, m).catch(console.error);\n        }, 0);\n    });\n};\n/**\n *  Represents any and all the buffered method calls that occurred before initialization.\n */\nvar PreInitMethodCallBuffer = /** @class */ (function () {\n    function PreInitMethodCallBuffer() {\n        this._value = {};\n    }\n    PreInitMethodCallBuffer.prototype.toArray = function () {\n        var _a;\n        return (_a = []).concat.apply(_a, Object.values(this._value));\n    };\n    PreInitMethodCallBuffer.prototype.getCalls = function (methodName) {\n        var _a;\n        return ((_a = this._value[methodName]) !== null && _a !== void 0 ? _a : []);\n    };\n    PreInitMethodCallBuffer.prototype.push = function () {\n        var _this = this;\n        var calls = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            calls[_i] = arguments[_i];\n        }\n        calls.forEach(function (call) {\n            if (_this._value[call.method]) {\n                _this._value[call.method].push(call);\n            }\n            else {\n                _this._value[call.method] = [call];\n            }\n        });\n        return this;\n    };\n    PreInitMethodCallBuffer.prototype.clear = function () {\n        this._value = {};\n        return this;\n    };\n    return PreInitMethodCallBuffer;\n}());\nexport { PreInitMethodCallBuffer };\n/**\n *  Call method and mark as \"called\"\n *  This function should never throw an error\n */\nexport function callAnalyticsMethod(analytics, call) {\n    return __awaiter(this, void 0, void 0, function () {\n        var result, err_1;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 3, , 4]);\n                    if (call.called) {\n                        return [2 /*return*/, undefined];\n                    }\n                    call.called = true;\n                    result = analytics[call.method].apply(analytics, call.args);\n                    if (!isThenable(result)) return [3 /*break*/, 2];\n                    // do not defer for non-async methods\n                    return [4 /*yield*/, result];\n                case 1:\n                    // do not defer for non-async methods\n                    _a.sent();\n                    _a.label = 2;\n                case 2:\n                    call.resolve(result);\n                    return [3 /*break*/, 4];\n                case 3:\n                    err_1 = _a.sent();\n                    call.reject(err_1);\n                    return [3 /*break*/, 4];\n                case 4: return [2 /*return*/];\n            }\n        });\n    });\n}\nvar AnalyticsBuffered = /** @class */ (function () {\n    function AnalyticsBuffered(loader) {\n        var _this = this;\n        this._preInitBuffer = new PreInitMethodCallBuffer();\n        this.trackSubmit = this._createMethod('trackSubmit');\n        this.trackClick = this._createMethod('trackClick');\n        this.trackLink = this._createMethod('trackLink');\n        this.pageView = this._createMethod('pageview');\n        this.identify = this._createMethod('identify');\n        this.reset = this._createMethod('reset');\n        this.group = this._createMethod('group');\n        this.track = this._createMethod('track');\n        this.ready = this._createMethod('ready');\n        this.alias = this._createMethod('alias');\n        this.debug = this._createChainableMethod('debug');\n        this.page = this._createMethod('page');\n        this.once = this._createChainableMethod('once');\n        this.off = this._createChainableMethod('off');\n        this.on = this._createChainableMethod('on');\n        this.addSourceMiddleware = this._createMethod('addSourceMiddleware');\n        this.setAnonymousId = this._createMethod('setAnonymousId');\n        this.addDestinationMiddleware = this._createMethod('addDestinationMiddleware');\n        this.screen = this._createMethod('screen');\n        this.register = this._createMethod('register');\n        this.deregister = this._createMethod('deregister');\n        this.user = this._createMethod('user');\n        this.VERSION = version;\n        this._promise = loader(this._preInitBuffer);\n        this._promise\n            .then(function (_a) {\n            var ajs = _a[0], ctx = _a[1];\n            _this.instance = ajs;\n            _this.ctx = ctx;\n        })\n            .catch(function () {\n            // intentionally do nothing...\n            // this result of this promise will be caught by the 'catch' block on this class.\n        });\n    }\n    AnalyticsBuffered.prototype.then = function () {\n        var _a;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return (_a = this._promise).then.apply(_a, args);\n    };\n    AnalyticsBuffered.prototype.catch = function () {\n        var _a;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return (_a = this._promise).catch.apply(_a, args);\n    };\n    AnalyticsBuffered.prototype.finally = function () {\n        var _a;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return (_a = this._promise).finally.apply(_a, args);\n    };\n    AnalyticsBuffered.prototype._createMethod = function (methodName) {\n        var _this = this;\n        return function () {\n            var _a;\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            if (_this.instance) {\n                var result = (_a = _this.instance)[methodName].apply(_a, args);\n                return Promise.resolve(result);\n            }\n            return new Promise(function (resolve, reject) {\n                _this._preInitBuffer.push({\n                    method: methodName,\n                    args: args,\n                    resolve: resolve,\n                    reject: reject,\n                    called: false,\n                });\n            });\n        };\n    };\n    /**\n     *  These are for methods that where determining when the method gets \"flushed\" is not important.\n     *  These methods will resolve when analytics is fully initialized, and return type (other than Analytics)will not be available.\n     */\n    AnalyticsBuffered.prototype._createChainableMethod = function (methodName) {\n        var _this = this;\n        return function () {\n            var _a;\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            if (_this.instance) {\n                void (_a = _this.instance)[methodName].apply(_a, args);\n                return _this;\n            }\n            else {\n                _this._preInitBuffer.push({\n                    method: methodName,\n                    args: args,\n                    resolve: function () { },\n                    reject: console.error,\n                    called: false,\n                });\n            }\n            return _this;\n        };\n    };\n    return AnalyticsBuffered;\n}());\nexport { AnalyticsBuffered };\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}