{"ast":null,"code":"/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n'use strict'; // NOTES //\n\n/*\n* => ldexp: load exponent (see [The Open Group]{@link http://pubs.opengroup.org/onlinepubs/9699919799/functions/ldexp.html} and [cppreference]{@link http://en.cppreference.com/w/c/numeric/math/ldexp}).\n*/\n// MODULES //\n\nvar PINF = require('@stdlib/constants-float64-pinf');\n\nvar NINF = require('@stdlib/constants-float64-ninf');\n\nvar BIAS = require('@stdlib/constants-float64-exponent-bias');\n\nvar MAX_EXPONENT = require('@stdlib/constants-float64-max-base2-exponent');\n\nvar MAX_SUBNORMAL_EXPONENT = require('@stdlib/constants-float64-max-base2-exponent-subnormal');\n\nvar MIN_SUBNORMAL_EXPONENT = require('@stdlib/constants-float64-min-base2-exponent-subnormal');\n\nvar isnan = require('@stdlib/math-base-assert-is-nan');\n\nvar isInfinite = require('@stdlib/math-base-assert-is-infinite');\n\nvar copysign = require('@stdlib/math-base-special-copysign');\n\nvar normalize = require('@stdlib/number-float64-base-normalize');\n\nvar floatExp = require('@stdlib/number-float64-base-exponent');\n\nvar toWords = require('@stdlib/number-float64-base-to-words');\n\nvar fromWords = require('@stdlib/number-float64-base-from-words'); // VARIABLES //\n// 1/(1<<52) = 1/(2**52) = 1/4503599627370496\n\n\nvar TWO52_INV = 2.220446049250313e-16; // Exponent all 0s: 1 00000000000 11111111111111111111 => 2148532223\n\nvar CLEAR_EXP_MASK = 0x800fffff >>> 0; // asm type annotation\n// Normalization workspace:\n\nvar FRAC = [0.0, 0.0]; // WARNING: not thread safe\n// High/low words workspace:\n\nvar WORDS = [0, 0]; // WARNING: not thread safe\n// MAIN //\n\n/**\n* Multiplies a double-precision floating-point number by an integer power of two.\n*\n* @param {number} frac - fraction\n* @param {integer} exp - exponent\n* @returns {number} double-precision floating-point number\n*\n* @example\n* var x = ldexp( 0.5, 3 ); // => 0.5 * 2^3 = 0.5 * 8\n* // returns 4.0\n*\n* @example\n* var x = ldexp( 4.0, -2 ); // => 4 * 2^(-2) = 4 * (1/4)\n* // returns 1.0\n*\n* @example\n* var x = ldexp( 0.0, 20 );\n* // returns 0.0\n*\n* @example\n* var x = ldexp( -0.0, 39 );\n* // returns -0.0\n*\n* @example\n* var x = ldexp( NaN, -101 );\n* // returns NaN\n*\n* @example\n* var x = ldexp( Infinity, 11 );\n* // returns Infinity\n*\n* @example\n* var x = ldexp( -Infinity, -118 );\n* // returns -Infinity\n*/\n\nfunction ldexp(frac, exp) {\n  var high;\n  var m;\n\n  if (frac === 0.0 || // handles +-0\n  isnan(frac) || isInfinite(frac)) {\n    return frac;\n  } // Normalize the input fraction:\n\n\n  normalize(FRAC, frac);\n  frac = FRAC[0];\n  exp += FRAC[1]; // Extract the exponent from `frac` and add it to `exp`:\n\n  exp += floatExp(frac); // Check for underflow/overflow...\n\n  if (exp < MIN_SUBNORMAL_EXPONENT) {\n    return copysign(0.0, frac);\n  }\n\n  if (exp > MAX_EXPONENT) {\n    if (frac < 0.0) {\n      return NINF;\n    }\n\n    return PINF;\n  } // Check for a subnormal and scale accordingly to retain precision...\n\n\n  if (exp <= MAX_SUBNORMAL_EXPONENT) {\n    exp += 52;\n    m = TWO52_INV;\n  } else {\n    m = 1.0;\n  } // Split the fraction into higher and lower order words:\n\n\n  toWords(WORDS, frac);\n  high = WORDS[0]; // Clear the exponent bits within the higher order word:\n\n  high &= CLEAR_EXP_MASK; // Set the exponent bits to the new exponent:\n\n  high |= exp + BIAS << 20; // Create a new floating-point number:\n\n  return m * fromWords(high, WORDS[1]);\n} // EXPORTS //\n\n\nmodule.exports = ldexp;","map":{"version":3,"names":["PINF","require","NINF","BIAS","MAX_EXPONENT","MAX_SUBNORMAL_EXPONENT","MIN_SUBNORMAL_EXPONENT","isnan","isInfinite","copysign","normalize","floatExp","toWords","fromWords","TWO52_INV","CLEAR_EXP_MASK","FRAC","WORDS","ldexp","frac","exp","high","m","module","exports"],"sources":["C:/Users/rober/Documents/copiaswaps-client/swaps-client/node_modules/@stdlib/math-base-special-ldexp/lib/ldexp.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// NOTES //\n\n/*\n* => ldexp: load exponent (see [The Open Group]{@link http://pubs.opengroup.org/onlinepubs/9699919799/functions/ldexp.html} and [cppreference]{@link http://en.cppreference.com/w/c/numeric/math/ldexp}).\n*/\n\n\n// MODULES //\n\nvar PINF = require( '@stdlib/constants-float64-pinf' );\nvar NINF = require( '@stdlib/constants-float64-ninf' );\nvar BIAS = require( '@stdlib/constants-float64-exponent-bias' );\nvar MAX_EXPONENT = require( '@stdlib/constants-float64-max-base2-exponent' );\nvar MAX_SUBNORMAL_EXPONENT = require( '@stdlib/constants-float64-max-base2-exponent-subnormal' );\nvar MIN_SUBNORMAL_EXPONENT = require( '@stdlib/constants-float64-min-base2-exponent-subnormal' );\nvar isnan = require( '@stdlib/math-base-assert-is-nan' );\nvar isInfinite = require( '@stdlib/math-base-assert-is-infinite' );\nvar copysign = require( '@stdlib/math-base-special-copysign' );\nvar normalize = require( '@stdlib/number-float64-base-normalize' );\nvar floatExp = require( '@stdlib/number-float64-base-exponent' );\nvar toWords = require( '@stdlib/number-float64-base-to-words' );\nvar fromWords = require( '@stdlib/number-float64-base-from-words' );\n\n\n// VARIABLES //\n\n// 1/(1<<52) = 1/(2**52) = 1/4503599627370496\nvar TWO52_INV = 2.220446049250313e-16;\n\n// Exponent all 0s: 1 00000000000 11111111111111111111 => 2148532223\nvar CLEAR_EXP_MASK = 0x800fffff>>>0; // asm type annotation\n\n// Normalization workspace:\nvar FRAC = [ 0.0, 0.0 ]; // WARNING: not thread safe\n\n// High/low words workspace:\nvar WORDS = [ 0, 0 ]; // WARNING: not thread safe\n\n\n// MAIN //\n\n/**\n* Multiplies a double-precision floating-point number by an integer power of two.\n*\n* @param {number} frac - fraction\n* @param {integer} exp - exponent\n* @returns {number} double-precision floating-point number\n*\n* @example\n* var x = ldexp( 0.5, 3 ); // => 0.5 * 2^3 = 0.5 * 8\n* // returns 4.0\n*\n* @example\n* var x = ldexp( 4.0, -2 ); // => 4 * 2^(-2) = 4 * (1/4)\n* // returns 1.0\n*\n* @example\n* var x = ldexp( 0.0, 20 );\n* // returns 0.0\n*\n* @example\n* var x = ldexp( -0.0, 39 );\n* // returns -0.0\n*\n* @example\n* var x = ldexp( NaN, -101 );\n* // returns NaN\n*\n* @example\n* var x = ldexp( Infinity, 11 );\n* // returns Infinity\n*\n* @example\n* var x = ldexp( -Infinity, -118 );\n* // returns -Infinity\n*/\nfunction ldexp( frac, exp ) {\n\tvar high;\n\tvar m;\n\tif (\n\t\tfrac === 0.0 || // handles +-0\n\t\tisnan( frac ) ||\n\t\tisInfinite( frac )\n\t) {\n\t\treturn frac;\n\t}\n\t// Normalize the input fraction:\n\tnormalize( FRAC, frac );\n\tfrac = FRAC[ 0 ];\n\texp += FRAC[ 1 ];\n\n\t// Extract the exponent from `frac` and add it to `exp`:\n\texp += floatExp( frac );\n\n\t// Check for underflow/overflow...\n\tif ( exp < MIN_SUBNORMAL_EXPONENT ) {\n\t\treturn copysign( 0.0, frac );\n\t}\n\tif ( exp > MAX_EXPONENT ) {\n\t\tif ( frac < 0.0 ) {\n\t\t\treturn NINF;\n\t\t}\n\t\treturn PINF;\n\t}\n\t// Check for a subnormal and scale accordingly to retain precision...\n\tif ( exp <= MAX_SUBNORMAL_EXPONENT ) {\n\t\texp += 52;\n\t\tm = TWO52_INV;\n\t} else {\n\t\tm = 1.0;\n\t}\n\t// Split the fraction into higher and lower order words:\n\ttoWords( WORDS, frac );\n\thigh = WORDS[ 0 ];\n\n\t// Clear the exponent bits within the higher order word:\n\thigh &= CLEAR_EXP_MASK;\n\n\t// Set the exponent bits to the new exponent:\n\thigh |= ((exp+BIAS) << 20);\n\n\t// Create a new floating-point number:\n\treturn m * fromWords( high, WORDS[ 1 ] );\n}\n\n\n// EXPORTS //\n\nmodule.exports = ldexp;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}