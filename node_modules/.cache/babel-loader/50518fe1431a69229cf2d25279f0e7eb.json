{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport unfetch from 'unfetch';\nvar fetch = unfetch;\n\nif (typeof window !== 'undefined') {\n  fetch = window.fetch || unfetch;\n}\n\nvar MAX_PAYLOAD_SIZE = 500;\n\nfunction kilobytes(buffer) {\n  var size = encodeURI(JSON.stringify(buffer)).split(/%..|./).length - 1;\n  return size / 1024;\n}\n/**\n * Checks if the payload is over or close to\n * the maximum payload size allowed by tracking\n * API.\n */\n\n\nfunction approachingTrackingAPILimit(buffer) {\n  return kilobytes(buffer) >= MAX_PAYLOAD_SIZE - 50;\n}\n\nfunction chunks(batch) {\n  var result = [];\n  var index = 0;\n  batch.forEach(function (item) {\n    var size = kilobytes(result[index]);\n\n    if (size >= 64) {\n      index++;\n    }\n\n    if (result[index]) {\n      result[index].push(item);\n    } else {\n      result[index] = [item];\n    }\n  });\n  return result;\n}\n\nexport default function batch(apiHost, config) {\n  var _a, _b;\n\n  var buffer = [];\n  var pageUnloaded = false;\n  var limit = (_a = config === null || config === void 0 ? void 0 : config.size) !== null && _a !== void 0 ? _a : 10;\n  var timeout = (_b = config === null || config === void 0 ? void 0 : config.timeout) !== null && _b !== void 0 ? _b : 5000;\n\n  function sendBatch(batch) {\n    var _a;\n\n    if (batch.length === 0) {\n      return;\n    }\n\n    var writeKey = (_a = batch[0]) === null || _a === void 0 ? void 0 : _a.writeKey;\n    return fetch(\"https://\".concat(apiHost, \"/b\"), {\n      keepalive: pageUnloaded,\n      headers: {\n        'Content-Type': 'text/plain'\n      },\n      method: 'post',\n      body: JSON.stringify({\n        batch: batch,\n        writeKey: writeKey\n      })\n    });\n  }\n\n  function flush() {\n    return __awaiter(this, void 0, void 0, function () {\n      var batch_1;\n      return __generator(this, function (_a) {\n        if (buffer.length) {\n          batch_1 = buffer;\n          buffer = [];\n          return [2\n          /*return*/\n          , sendBatch(batch_1)];\n        }\n\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  }\n\n  var schedule;\n\n  function scheduleFlush() {\n    if (schedule) {\n      return;\n    }\n\n    schedule = setTimeout(function () {\n      schedule = undefined;\n      flush().catch(console.error);\n    }, timeout);\n  }\n\n  window.addEventListener('beforeunload', function () {\n    pageUnloaded = true;\n\n    if (buffer.length) {\n      var reqs = chunks(buffer).map(sendBatch);\n      Promise.all(reqs).catch(console.error);\n    }\n  });\n\n  function dispatch(_url, body) {\n    return __awaiter(this, void 0, void 0, function () {\n      var bufferOverflow;\n      return __generator(this, function (_a) {\n        buffer.push(body);\n        bufferOverflow = buffer.length >= limit || approachingTrackingAPILimit(buffer);\n        return [2\n        /*return*/\n        , bufferOverflow || pageUnloaded ? flush() : scheduleFlush()];\n      });\n    });\n  }\n\n  return {\n    dispatch: dispatch\n  };\n}","map":{"version":3,"sources":["../../../../src/plugins/segmentio/batched-dispatcher.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __awaiter, __generator } from \"tslib\";\nimport unfetch from 'unfetch';\nvar fetch = unfetch;\nif (typeof window !== 'undefined') {\n    fetch = window.fetch || unfetch;\n}\nvar MAX_PAYLOAD_SIZE = 500;\nfunction kilobytes(buffer) {\n    var size = encodeURI(JSON.stringify(buffer)).split(/%..|./).length - 1;\n    return size / 1024;\n}\n/**\n * Checks if the payload is over or close to\n * the maximum payload size allowed by tracking\n * API.\n */\nfunction approachingTrackingAPILimit(buffer) {\n    return kilobytes(buffer) >= MAX_PAYLOAD_SIZE - 50;\n}\nfunction chunks(batch) {\n    var result = [];\n    var index = 0;\n    batch.forEach(function (item) {\n        var size = kilobytes(result[index]);\n        if (size >= 64) {\n            index++;\n        }\n        if (result[index]) {\n            result[index].push(item);\n        }\n        else {\n            result[index] = [item];\n        }\n    });\n    return result;\n}\nexport default function batch(apiHost, config) {\n    var _a, _b;\n    var buffer = [];\n    var pageUnloaded = false;\n    var limit = (_a = config === null || config === void 0 ? void 0 : config.size) !== null && _a !== void 0 ? _a : 10;\n    var timeout = (_b = config === null || config === void 0 ? void 0 : config.timeout) !== null && _b !== void 0 ? _b : 5000;\n    function sendBatch(batch) {\n        var _a;\n        if (batch.length === 0) {\n            return;\n        }\n        var writeKey = (_a = batch[0]) === null || _a === void 0 ? void 0 : _a.writeKey;\n        return fetch(\"https://\".concat(apiHost, \"/b\"), {\n            keepalive: pageUnloaded,\n            headers: {\n                'Content-Type': 'text/plain',\n            },\n            method: 'post',\n            body: JSON.stringify({ batch: batch, writeKey: writeKey }),\n        });\n    }\n    function flush() {\n        return __awaiter(this, void 0, void 0, function () {\n            var batch_1;\n            return __generator(this, function (_a) {\n                if (buffer.length) {\n                    batch_1 = buffer;\n                    buffer = [];\n                    return [2 /*return*/, sendBatch(batch_1)];\n                }\n                return [2 /*return*/];\n            });\n        });\n    }\n    var schedule;\n    function scheduleFlush() {\n        if (schedule) {\n            return;\n        }\n        schedule = setTimeout(function () {\n            schedule = undefined;\n            flush().catch(console.error);\n        }, timeout);\n    }\n    window.addEventListener('beforeunload', function () {\n        pageUnloaded = true;\n        if (buffer.length) {\n            var reqs = chunks(buffer).map(sendBatch);\n            Promise.all(reqs).catch(console.error);\n        }\n    });\n    function dispatch(_url, body) {\n        return __awaiter(this, void 0, void 0, function () {\n            var bufferOverflow;\n            return __generator(this, function (_a) {\n                buffer.push(body);\n                bufferOverflow = buffer.length >= limit || approachingTrackingAPILimit(buffer);\n                return [2 /*return*/, bufferOverflow || pageUnloaded ? flush() : scheduleFlush()];\n            });\n        });\n    }\n    return {\n        dispatch: dispatch,\n    };\n}\n//# sourceMappingURL=batched-dispatcher.js.map"]},"metadata":{},"sourceType":"module"}