{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Page = void 0;\n\nvar inherits_1 = __importDefault(require(\"inherits\"));\n\nvar facade_1 = require(\"./facade\");\n\nvar track_1 = require(\"./track\");\n\nvar is_email_1 = __importDefault(require(\"./is-email\"));\n\nfunction Page(dictionary, opts) {\n  facade_1.Facade.call(this, dictionary, opts);\n}\n\nexports.Page = Page;\ninherits_1.default(Page, facade_1.Facade);\nvar p = Page.prototype;\n\np.action = function () {\n  return \"page\";\n};\n\np.type = p.action;\np.category = facade_1.Facade.field(\"category\");\np.name = facade_1.Facade.field(\"name\");\np.title = facade_1.Facade.proxy(\"properties.title\");\np.path = facade_1.Facade.proxy(\"properties.path\");\np.url = facade_1.Facade.proxy(\"properties.url\");\n\np.referrer = function () {\n  return this.proxy(\"context.referrer.url\") || this.proxy(\"context.page.referrer\") || this.proxy(\"properties.referrer\");\n};\n\np.properties = function (aliases) {\n  var props = this.field(\"properties\") || {};\n  var category = this.category();\n  var name = this.name();\n  aliases = aliases || {};\n  if (category) props.category = category;\n  if (name) props.name = name;\n\n  for (var alias in aliases) {\n    var value = this[alias] == null ? this.proxy(\"properties.\" + alias) : this[alias]();\n    if (value == null) continue;\n    props[aliases[alias]] = value;\n    if (alias !== aliases[alias]) delete props[alias];\n  }\n\n  return props;\n};\n\np.email = function () {\n  var email = this.proxy(\"context.traits.email\") || this.proxy(\"properties.email\");\n  if (email) return email;\n  var userId = this.userId();\n  if (is_email_1.default(userId)) return userId;\n};\n\np.fullName = function () {\n  var category = this.category();\n  var name = this.name();\n  return name && category ? category + \" \" + name : name;\n};\n\np.event = function (name) {\n  return name ? \"Viewed \" + name + \" Page\" : \"Loaded a Page\";\n};\n\np.track = function (name) {\n  var json = this.json();\n  json.event = this.event(name);\n  json.timestamp = this.timestamp();\n  json.properties = this.properties();\n  return new track_1.Track(json, this.opts);\n};","map":{"version":3,"sources":["../lib/page.js"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\n\nimport inherit from \"inherits\";\nimport { Facade } from \"./facade\";\nimport { Track } from \"./track\";\nimport isEmail from \"./is-email\";\n\n/**\n * Initialize a new `Page` facade with a `dictionary` of arguments.\n *\n * @param {Object} dictionary - The object to wrap.\n * @param {string} [dictionary.category] - The page category.\n * @param {string} [dictionary.name] - The page name.\n * @param {string} [dictionary.properties] - The page properties.\n * @param {Object} opts - Options about what kind of Facade to create.\n *\n * @augments Facade\n */\nexport function Page(dictionary, opts) {\n  Facade.call(this, dictionary, opts);\n}\n\ninherit(Page, Facade);\n\nconst p = Page.prototype;\n\n/**\n * Return the type of facade this is. This will always return `\"page\"`.\n *\n * @return {string}\n */\np.action = function () {\n  return \"page\";\n};\n\n/**\n * An alias for {@link Page#action}.\n *\n * @function\n * @return {string}\n */\np.type = p.action;\n\n/**\n * Get the page category from `category`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\np.category = Facade.field(\"category\");\n\n/**\n * Get the page name from `name`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\np.name = Facade.field(\"name\");\n\n/**\n * Get the page title from `properties.title`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\np.title = Facade.proxy(\"properties.title\");\n\n/**\n * Get the page path from `properties.path`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\np.path = Facade.proxy(\"properties.path\");\n\n/**\n * Get the page URL from `properties.url`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\np.url = Facade.proxy(\"properties.url\");\n\n/**\n * Get the HTTP referrer from `context.referrer.url`, `context.page.referrer`,\n * or `properties.referrer`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\np.referrer = function () {\n  return (\n    this.proxy(\"context.referrer.url\") ||\n    this.proxy(\"context.page.referrer\") ||\n    this.proxy(\"properties.referrer\")\n  );\n};\n\n/**\n * Get the page's properties. This is identical to how {@link Facade#traits}\n * works, except it looks at `properties.*` instead of `options.traits.*`.\n *\n * Properties are gotten from `properties`, augmented with the page's `name`\n * and `category`.\n *\n * The parameter `aliases` is meant to transform keys in `properties` into new\n * keys. Each alias like `{ \"xxx\": \"yyy\" }` will take whatever is at `xxx` in\n * the traits, and move it to `yyy`. If `xxx` is a method of this facade, it'll\n * be called as a function instead of treated as a key into the traits.\n *\n * @example\n * let obj = { properties: { foo: \"bar\" }, anonymousId: \"xxx\" }\n * let page = new Page(obj)\n *\n * page.traits() // { \"foo\": \"bar\" }\n * page.traits({ \"foo\": \"asdf\" }) // { \"asdf\": \"bar\" }\n * page.traits({ \"sessionId\": \"rofl\" }) // { \"rofl\": \"xxx\" }\n *\n * @param {Object} aliases - A mapping from keys to the new keys they should be\n * transformed to.\n * @return {Object}\n */\np.properties = function (aliases) {\n  let props = this.field(\"properties\") || {};\n  let category = this.category();\n  let name = this.name();\n  aliases = aliases || {};\n\n  if (category) props.category = category;\n  if (name) props.name = name;\n\n  for (let alias in aliases) {\n    let value =\n      this[alias] == null ? this.proxy(\"properties.\" + alias) : this[alias]();\n    if (value == null) continue;\n    props[aliases[alias]] = value;\n    if (alias !== aliases[alias]) delete props[alias];\n  }\n\n  return props;\n};\n\n/**\n * Get the user's email from `context.traits.email` or `properties.email`,\n * falling back to `userId` if it's a valid email.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\np.email = function () {\n  let email =\n    this.proxy(\"context.traits.email\") || this.proxy(\"properties.email\");\n  if (email) return email;\n\n  let userId = this.userId();\n  if (isEmail(userId)) return userId;\n};\n\n/**\n * Get the page fullName. This is `$category $name` if both are present, and\n * just `name` otherwiser.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\np.fullName = function () {\n  let category = this.category();\n  let name = this.name();\n  return name && category ? category + \" \" + name : name;\n};\n\n/**\n * Get an event name from this page call. If `name` is present, this will be\n * `Viewed $name Page`; otherwise, it will be `Loaded a Page`.\n *\n * @param {string} name - The name of this page.\n * @return {string}\n */\np.event = function (name) {\n  return name ? \"Viewed \" + name + \" Page\" : \"Loaded a Page\";\n};\n\n/**\n * Convert this Page to a {@link Track} facade. The inputted `name` will be\n * converted to the Track's event name via {@link Page#event}.\n *\n * @param {string} name\n * @return {Track}\n */\np.track = function (name) {\n  let json = this.json();\n  json.event = this.event(name);\n  json.timestamp = this.timestamp();\n  json.properties = this.properties();\n  return new Track(json, this.opts);\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}